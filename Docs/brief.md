# Общее описание функционала веб сервера
Сервер представляет из себя Платформу для AI обработки фотографий. 
## Пользовательский workflow
 
 Пользователь авторизуется в веб интерфейсе платформы и попадает на Главную страницу выбора слота настроек. Выбирая соответствующий слот, пользователь попадает в Страницу-вкладку настроек обработки фотографии. 

**Процесс настройки слота:**
1.  **Выбор Провайдера:** Пользователь выбирает из списка, какую AI-платформу использовать (например, `Gemini`, `Turbotext`).
2.  **Выбор Операции:** В зависимости от выбранного провайдера, появляется второй список с доступными операциями (например, для `Gemini` это будут `Style Transfer`, `Identity Transfer`, `Image Edit`).
3.  **Настройка Параметров:** Интерфейс автоматически отображает поля, необходимые именно для этой операции (например, текстовый промпт, поле для загрузки стилевого изображения и т.д.).

После настройки пользователь сохраняет слот. На главной странице в списке слотов теперь отображается имя этого слота и рядом отображена ingest-ссылка. Рядом с сылкой присутствует кнопка "Копировать" для копирования ссылки. Пользователь копирует ingest-ссылку слота и вставляет ее в DSLR Remote Pro. Теперь программа отправляет `POST` c файлом на этот адрес. В теле `POST` находится обрабатываемая фотография, пароль и некоторые другие поля.

> **Важно:** со стороны DSLR Remote Pro нам известна только фактическая форма запроса (см. пример ниже). Из обязательных полей подтверждены `password` и данные, описывающие отправляемую фотографию (сама фотография и её метаданные). Остальные поля обрабатываются как опциональные, пока не появится официальная документация.


## Цель платформы
Ожидать ingest-POST на разных эндпоинтах и, согласно слоту, вызывать соответствующую AI-модель.
По получению запроса, в зависимости от того на какой входящий эндпоинт он пришел, платформа формирует исходящий запрос к соответствующей AI модели для обработки фотографии. Запрос формируется на основании данных из слота, к которому привязан входящий эндпоинт. Платформа получает тем или иным методом обработанную фотографию от AI модели и возвращает её в теле ответа на пользовательский POST запрос. Исходная фотография хранится во временном хранилище только пока задача находится в статусах `pending`/`processing` и максимум `T_ingest_ttl`, где `T_ingest_ttl = min(T_sync_response, T_public_link_ttl)` и `T_public_link_ttl = clamp(T_sync_response, 45, 60)`; по наступлении дедлайна или финализации файл удаляется безусловно. Временные публичные ссылки `media_object` живут `T_public_link_ttl` секунд и не продлеваются: если провайдер не скачал файл за это время, задача получает `failure_reason = 'timeout'`, а временные данные удаляются. Для соблюдения этого окна дедлайн задачи (`Job.expires_at`) фиксируется с запасом `T_job_deadline = max(T_sync_response, T_public_link_ttl)`, поэтому фоновые процессы и очистка опираются на единый момент времени, который не короче `T_public_link_ttl`. Обработанные фотографии хранятся непосредственно в записи Job (поле `result`) как последний успешный ответ и автоматически очищаются спустя 72 часа (`media_cache.processed_media_ttl_hours`); повторный запуск перезаписывает содержимое. Административные действия (включая `POST /api/media/cache/purge`) не удаляют активный результат досрочно.

### Провайдер Gemini (image generation & editing)

- Поддерживаемые сценарии — генерация изображений, редактирование «edit-with-prompt», multi-image fusion и стилизация на модели `gemini-2.5-flash-image`.
- Все запросы выполняются методом `models.generateContent` с передачей текста и изображений через `contents.parts` (`text`, `inline_data`, `file_data`). Для крупных файлов используется Files API (`file_uri`), который хранит до 2 ГБ на файл и 20 ГБ на проект в течение 48 часов.
- Лимиты Gemini, обязательные к соблюдению: Files API принимает изображения только `image/png`, `image/jpeg`, `image/webp`, `image/heic`, `image/heif`; каждый файл ≤ 2 ГБ, суммарное хранилище проекта ≤ 20 ГБ, файлы удаляются спустя 48 ч; базовые квоты модели `gemini-2.5-flash-image` — 500 запросов в минуту, 2 000 запросов в день и 500 000 токенов в минуту (Tier 2). UI и валидация должны учитывать эти ограничения.

# Механизм работы платформы

Платформа использует архитектуру "Асинхронного моста" для обработки запросов от DSLR Remote Pro в рамках 50‑секундного таймаута, даже если AI‑модель работает дольше. Значение таймаута (`T_sync_response`, по умолчанию 48 с, допустимый диапазон 45–60 с) настраивается на странице настроек и управляет временными TTL, живущими не дольше минуты.

1. Приём запроса: Ingest API получает POST и валидирует вход (MIME/размер/EXIF и т.п.).
2. Постановка в очередь: запрос безусловно фиксируется в таблице `job` PostgreSQL, которая выступает единой очередью с персистентным back-pressure. Запись выполняется в транзакции вместе с валидацией входа; по переполнению очереди API отклоняет новый ingest (429/503 в зависимости от политики), чтобы не превышать лимиты.
3. Ожидание с таймаутом: обработчик API ждёт результат не дольше ~48 c (внутреннее ожидание строго < `T_sync_response`). Как только наступает
   `T_sync_response`, API **безусловно** завершает ingest с ошибкой 504, даже если воркер ещё взаимодействует с провайдером.
4. Фоновая обработка: worker(ы) выбирают задачи из таблицы `job` (`SELECT … FOR UPDATE SKIP LOCKED`), вызывают внешнего AI‑провайдера и обновляют
   `Job.status = 'processing'`. Если провайдер возвращает `async_id`, ожидание переносится на webhook/поллинг, но воркер отслеживает дедлайн
   `T_sync_response`, чтобы успеть либо получить результат, либо отменить задачу вовремя.
5. Финализация задачи (фиксируется только внутри окна `T_sync_response`):
   - Успех: воркер успевает получить результат, заполняет поля `Job.result_*`, выставляет `is_finalized = true`, `failure_reason = null`
     и возвращает изображение в API → клиент получает 200 OK. После этого очищаются только исходные файлы (`payload_path`/`source_media_id`).
   - Таймаут: при достижении `T_sync_response` API возвращает 504 Gateway Timeout, выставляет `is_finalized = true` и `failure_reason = 'timeout'`
     и отправляет воркеру сигнал отмены. Воркер прекращает обращения к провайдеру, удаляет временные данные, поле `result` остаётся пустым.
   - Ошибка провайдера: если внешнее API вернуло ошибку или исчерпаны ретраи до дедлайна, воркер устанавливает `is_finalized = true`,
     `failure_reason = 'provider_error'`, освобождает ресурсы и возвращает ошибку (504/502) через API.
   - Отмена: внешнее вмешательство переводит задачу в `is_finalized = true`, `failure_reason = 'cancelled'` и инициирует очистку временных данных.

6. Ретраи и back‑pressure: для MVP допускается только одна попытка вызова провайдера. Ограничение параллелизма реализовано на уровне
   выборки задач (`SELECT … FOR UPDATE SKIP LOCKED`) и настройке воркеров: пока `Job.status = 'processing'`, новые воркеры не берут задачу.
   Если дедлайн наступил до получения результата, воркер снимает блокировку, задача фиксируется как финализированная с `failure_reason =
   'timeout'`, а повтор возможен только через новый POST от клиента. Дополнительных счётчиков и планировщиков ретраев не требуется.
Временные ссылки (`media_object`) живут фиксированное время `T_public_link_ttl = clamp(T_sync_response, 45, 60)` секунд. Если за это окно провайдер не скачал файл, задача считается
невыполненной: воркер выставляет `failure_reason = 'timeout'`, временные данные удаляются, и повторный запуск возможен только через новый POST.
Если результат от провайдера не пришёл в течение `T_sync_response`, ingest завершается 504, `is_finalized = true`, `failure_reason = 'timeout'`,
и поле `result` остаётся пустым; возобновление возможно только через новый POST от клиента.

### DeadlineGuard — единый контроль дедлайнов и TTL

Для синхронизации всех таймеров введён сервис `DeadlineGuard`, который поднимается вместе с приложением и предоставляет API, воркерам и системам хранения общие хелперы работы с дедлайнами.

- **Источники конфигурации:**
- `T_sync_response` — `app_settings["ingest.sync_response_timeout_sec"]`, по умолчанию 48 секунд; допустимый диапазон настройки 45–60 секунд.
- `T_public_link_ttl` — `app_settings["media.public_link_ttl_sec"] = clamp(T_sync_response, 45, 60)`; жёсткий лимит времени жизни публичных ссылок Turbotext и других внешних временных артефактов.
- `T_ingest_ttl` — `app_settings["media.ingest_ttl_sec"] = min(T_sync_response, T_public_link_ttl)`; определяет TTL исходных payload и всегда не превышает `T_sync_response`.
- **Единый дедлайн Job:** при создании записи `Job` фиксируется поле `expires_at = created_at + T_job_deadline`, где `T_job_deadline = max(T_sync_response, T_media_limit_max)` и `T_media_limit_max` — максимальный лимит среди задействованных временных хранилищ (для публичных ссылок используется `T_public_link_ttl`). Значение хранится в БД и не меняется; API, воркеры и механизмы очистки получают дедлайн только через `DeadlineGuard`.
- **Политика TTL артефактов:** для всех временных объектов применяется формула `artifact_expires_at = min(created_at + T_media_limit, job.expires_at)`. Поскольку `job.expires_at` всегда не меньше соответствующего лимита, ссылка Turbotext гарантированно живёт `T_public_link_ttl` секунд, а остальные объекты не выходят за рамки собственного окна или дедлайна задачи.
- **Интеграция:**
  - Ingest API вызывает `deadline_guard.attach(job)` при создании задачи и использует `job.expires_at` в цикле ожидания; ответ остаётся бинарным/общей ошибкой согласно контракту ingest и не содержит отдельных полей дедлайна.
  - Воркеры рассчитывают оставшееся время через `deadline_guard.for_job(job_id)` и перед каждой попыткой взаимодействия с провайдером проверяют `deadline_guard.should_abort()`; отмена запускает очистку временных данных через хелперы сервиса.
  - Очистка временных файлов и публичных ссылок использует `deadline_guard.lease(ttl_kind, created_at)` и периодическую задачу `deadline_guard.gc()`, чтобы удалять артефакты сразу после наступления `job.expires_at`.

```mermaid
sequenceDiagram
    participant DSLR as DSLR Remote Pro
    participant API as Ingest API
    participant Queue as Очередь задач (PostgreSQL job)
    participant Worker as AI Worker
    participant AI_Provider as AI Провайдер
    participant JobStore as Таблица job/result

    DSLR->>API: POST /ingest/{slotId} с фото
    activate API
    API->>Queue: Поставить задачу в очередь
    API->>API: Начать ожидание результата (~48с)
    Queue->>Worker: Отправить задачу на обработку
    activate Worker
    Worker->>AI_Provider: Запрос на обработку фото
    activate AI_Provider
    AI_Provider-->>Worker: Готовое изображение (или async_id)
    deactivate AI_Provider
    Worker->>JobStore: Обновить запись Job (result + is_finalized)
    Worker->>API: Уведомить о результате (при sync)
    API-->>DSLR: Отправить обработанное фото (HTTP 200 OK)
    deactivate API
    deactivate Worker

    alt Таймаут
        API->>API: Ожидание превысило ~48с
        API-->>DSLR: Вернуть ошибку 504
        API-->>Worker: Отменить задачу (failure_reason = 'timeout')
        Worker->>JobStore: Зафиксировать отмену, очистить временные данные
        note over API,Worker: После 48с задача завершается окончательно; для повторной обработки нужен новый POST
    end
```

## Временное публичное медиа-хранилище (для Turbotext)
Назначение: выдавать временные публичные ссылки на изображения, чтобы передавать их в поля url_image_target и url Turbotext.

### Краткие требования
- TTL ссылки совпадает с `T_public_link_ttl = clamp(T_sync_response, 45, 60)` секунд. Продление не предусмотрено: по истечении этого окна ссылка и файл удаляются, связанные задачи получают `failure_reason = 'timeout'`.
- Форматы: строго JPEG/PNG/WEBP. Этот набор зафиксирован в `MEDIA_ALLOWED_MIME = ["image/jpeg", "image/png", "image/webp"]`
  и обязателен для всех провайдеров, использующих публичные ссылки (например, Turbotext). Добавление других форматов требует
  отдельного обновления брифа и синхронизации конфигурации.
- Размеры: лимит по размеру файла и по пикселям (конфиг).
- Хранение: локальная папка MEDIA_ROOT; автоматическая очистка просроченных файлов.
### Конфигурация (параметры)

* MEDIA_ROOT — путь для временных файлов (например, /var/app/media/tmp)
* PUBLIC_BASE_URL — базовый URL для раздачи (например, https://api.example.com/public/media)
* MEDIA_PUBLIC_LINK_TTL_SEC — вычисляемое время жизни ссылок (`clamp(T_sync_response, 45, 60)` секунд)
* MEDIA_ALLOWED_MIME — список допустимых MIME (финально: `image/jpeg`, `image/png`, `image/webp`)
* MEDIA_MAX_FILE_SIZE_MB — лимит размера

### Эндпоинты (минимальный набор)

#### `POST /api/media/register`

* **Назначение:** загрузить временный файл, сохранить его в `MEDIA_ROOT` и выдать публичную ссылку с ограниченным сроком жизни. Используется только для временных объектов (`media_object`), не для шаблонов.
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `slots:write`.
* **Content-Type:** `multipart/form-data`.
* **Тело запроса:**
  * `file` (`binary`, **обязательный**) — содержимое изображения. Допустимые MIME перечислены в `MEDIA_ALLOWED_MIME`.
  * `job_id` (`uuid`, опционально) — идентификатор задачи, к которой привязывается файл (для последующей автоочистки).
* **Лимиты:**
  * Размер файла — ≤ `MEDIA_MAX_FILE_SIZE_MB` (ответ `413` при превышении).
  * Форматы — только перечисленные в `MEDIA_ALLOWED_MIME` (иначе `415`).
  * TTL — ссылка истекает через `MEDIA_PUBLIC_LINK_TTL_SEC = clamp(T_sync_response, 45, 60)` секунд после регистрации (`expires_at = now + MEDIA_PUBLIC_LINK_TTL_SEC`). Для файлов, связанных с активной ingest-задачей (`job_id` не `null`), воркер отслеживает наступление `T_sync_response`; если провайдер не скачал файл до истечения TTL, задача получает `failure_reason = 'timeout'`.
  * Отдельный эндпоинт для продления (`/api/media/extend`) не предоставляется: при необходимости получить новую ссылку файл регистрируется повторно.
* **Успешный ответ (`201 Created`):**
  ```json
  {
    "id": "7f6c9d44-221a-4895-9f63-5e9f7137ba3f",
    "public_url": "https://api.example.com/public/media/7f6c9d44-221a-4895-9f63-5e9f7137ba3f",
    "expires_at": "2024-07-09T12:45:30Z"
  }
  ```
* **Ошибки:**
  * `400` — отсутствует файл или нарушены ограничения TTL/поля запроса.
  * `401`/`403` — неавторизованно или недостаточно прав.
  * `413` — файл превышает лимит размера.
  * `415` — MIME не поддерживается.
  * `429` — превышена квота загрузок (rate-limit на пользователя/клиента).
  * `500` — внутренняя ошибка сервиса.
  * `503` — временно недоступно (например, локальное хранилище переполнено или сервис в режиме обслуживания).

**Пример запроса:**

```http
POST /api/media/register HTTP/1.1
Host: api.example.com
Authorization: Bearer <JWT>
Content-Type: multipart/form-data; boundary=boundary123

--boundary123
Content-Disposition: form-data; name="file"; filename="target.jpg"
Content-Type: image/jpeg

<binary jpeg data>
--boundary123--
```

**Пример успешного ответа (`201 Created`):**

```http
HTTP/1.1 201 Created
Content-Type: application/json

{"id":"7f6c9d44-221a-4895-9f63-5e9f7137ba3f","public_url":"https://api.example.com/public/media/7f6c9d44-221a-4895-9f63-5e9f7137ba3f","expires_at":"2024-07-09T12:45:30Z"}
```

#### `GET /public/media/{id}`

* **Назначение:** отдать временно опубликованный файл по идентификатору.
* **Аутентификация:** не требуется; ссылка работает до наступления `expires_at`.
* **Параметры пути:** `id` (`uuid`, **обязательный**).
* **Успешный ответ (`200 OK`):**
  * `Content-Type` — MIME исходного файла (например, `image/jpeg`).
  * `Cache-Control: private, max-age=0` (чтобы браузер не кэшировал истекшее содержимое).
  * Тело содержит бинарные данные изображения.
* **Ошибки:**
  * `400` — неверный формат идентификатора.
  * `404` — файл не существует или уже удалён системой очистки.
  * `410` — ссылка истекла (`expires_at < now`); тело ошибки соответствует общему формату и имеет код `media_link_expired`.
  * `429` — превышен лимит скачиваний по публичной ссылке.
  * `500`/`503` — ошибка файлового хранилища или недоступность сервиса.

**Пример успешного ответа (`200 OK`):**

```http
HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 582913

<binary jpeg data>
```

**Пример ошибки истекшей ссылки (`410 Gone`):**

```http
HTTP/1.1 410 Gone
Content-Type: application/json

{"error":{"code":"media_link_expired","message":"Ссылка больше недоступна","details":{"id":"7f6c9d44-221a-4895-9f63-5e9f7137ba3f"}}}
```

- `POST /api/template-media/register` — загрузить постоянный шаблон, вернуть `template_media_id`, относительный путь и метаданные; обновляет привязки слота.
- `DELETE /api/template-media/{id}` — удалить шаблон и очистить привязки; используется кнопкой «Убрать» на странице слота.

> **Аутентификация:** для операций с временными файлами используется общая JWT-схема платформы (`Authorization: Bearer <JWT>`). `GET /public/media/{id}` остаётся публичным, но возвращает `410` при истечении TTL и `404`, если файл уже удалён. Управление шаблонами требует прав `slots:write`.

### Жизненный цикл
- Ingest принял фото → зарегистрировал в медиа-хранилище → получил public_url.
- Воркер передал public_url в запрос к Turbotext.
- Turbotext скачал файл по ссылке и выполнил операцию.
- Пока задача в статусах `pending`/`processing`, временный файл живёт до истечения базового `expires_at`, которое не превышает `T_sync_response` (диапазон 45–60 с) и не продлевается автоматически.
- По завершении задачи с `failure_reason = null` файл остаётся доступным до `expires_at`; при `failure_reason` в состояниях `timeout`, `provider_error` или `cancelled` воркер помечает запись на немедленное удаление.
- Плановая очистка регулярно удаляет просроченные файлы и записи.

### Постоянное хранилище шаблонов (`template_media`)
- **Назначение:** хранить многоразовые эталонные изображения (стили, лица, фоны), которые администраторы загружают один раз и
  привязывают к слотам. Эти файлы не удаляются автоматически и используются при каждом запуске соответствующего слота.
- **Каталог:** `MEDIA_ROOT/templates` (иерархия по префиксу UUID или checksum). Файлы выкладываются только из бек-офиса; публичных
  прямых ссылок нет — доступ к содержимому выдаётся воркеру через файловую систему.
- **Таблица `template_media`:**
  * `id` (`UUID`, PK) — идентификатор, который сохраняется в `Slot.settings_json`.
  * `path` (`TEXT`) — относительный путь в `MEDIA_ROOT/templates`.
  * `mime` (`TEXT`), `size_bytes` (`INTEGER`), `checksum` (`TEXT`) — метаданные для контроля целостности.
  * `uploaded_by` (`INTEGER`, FK → `User`), `created_at` (`TIMESTAMPTZ`).
  * `label` (`TEXT`, nullable) — человекочитаемое имя шаблона для UI.
- **Таблица связей `slot_template_binding`:** (`slot_id` `TEXT` FK → `Slot`, `setting_key` `TEXT`, `template_media_id` `UUID` FK →
  `template_media`, `created_at` `TIMESTAMPTZ`). Используется для аудита и повторной синхронизации, когда слот обновляет набор
  шаблонов. При изменении `settings_json` привязки пересоздаются.
- **Отсутствие авто-GC:** очистители `media_object`/TTL не затрагивают `template_media`; удаление выполняется только по явному
  запросу администратора через API или UI.
- **Права доступа:** загрузка/удаление доступны пользователям с `slots:write`. Чтение выполняется опосредованно — воркеры и UI
  используют ID шаблона из настроек слота, прямых GET-эндпоинтов без авторизации нет.

## Turbotext: очередь, polling и webhook

**Создание задачи**

```http
POST /api_ai/<method> HTTP/1.1
Host: turbotext.ru
Authorization: Bearer {APIKEY}
Content-Type: application/x-www-form-urlencoded

do=create_queue
webhook=https://example.com/hook (опционально)
<поля метода>
```

- Ответ без webhook: `{"success": true, "queueid": <ID>}`. Это значение должно сохраняться в `Job.external_ref` для последующего опроса.
- Ответ с webhook: `{"success": true, "asyncid": <ID>}` — идентификатор совпадает с очередью, worker больше не опрашивает Turbotext и ждёт POST от провайдера.
- Turbotext обязан скачать переданные `url`/`url_image_target` сразу после регистрации файла: по истечении базового TTL (`T_public_link_ttl = clamp(T_sync_response, 45, 60)`) ссылка истекает без продления со стороны платформы.

**Опрос результата**

```http
POST /api_ai/<method> HTTP/1.1
Authorization: Bearer {APIKEY}
Content-Type: application/x-www-form-urlencoded

do=get_result
queueid:<ID>
```

- Пока задача в работе, Turbotext возвращает `{"action": "reconnect"}` и не увеличивает счётчик попыток.
- После завершения приходит JSON с полями `success`, `error`, `data`, `uploaded_image` и (иногда) `limits`.

**Финальный JSON (для polling и webhook одинаковый):**

```json
{
  "success": true,
  "error": "",
  "data": {
    "image": ["image/<method>_id12_0.png"],
    "prompt": "...",
    "width": 768,
    "height": 768,
    "face_restore": "False"
  },
  "uploaded_image": "https://www.turbotext.ru/download.php?f=....png",
  "limits": { "foto_limit": 123, "text_limit": 123 }
}
```

- Параметр `uploaded_image` содержит прямую ссылку на результат — её нужно скачать и сохранить во временное хранилище результатов.
- Turbotext присылает webhook в формате идентичном успешному ответу `do=get_result`; сервис обязан вернуть HTTP 200.

# Архитектура и стек приложения
## Архитектура
**1. Архитектура проекта ориентирована на безопасность изменений кода** при генерации кода LLM моделью: тонкие фасады + pure domain + контракт-first + Spec Driven Dev
**2. Архитектура проекта должна обладать Низкой связанностью (low coupling):**
 * Каждый модуль/фасад имеет отдельную ответственность.
 * Сервисы и домен не знают про инфраструктуру напрямую — используют фасады и интерфейсы.
 * Любой слой зависит только от более внутреннего слоя.
**3. Архитектура проекта должна обладать Высокой когезией (high cohesion):**
 * Каждый класс или модуль отвечает за один аспект.
 * DTO и типы фиксируют контракты между слоями, уменьшая «размазанность» логики.

### Модели данных (PostgreSQL + Alembic)
Для хранения состояния приложения, настроек слотов и сбора статистики будет использоваться база данных PostgreSQL; схемы версионируются через Alembic (миграции)
Все временные метки храним как `TIMESTAMP WITH TIME ZONE` (UTC). Для полей со схемами и настройками допускается `JSONB`.

**Таблица `User`**

*   `id`: `INTEGER` (Primary Key)
*   `username`: `TEXT` (уникальный; в боевой конфигурации допустимы только два предустановленных значения — `serg` и `igor`)
*   `hashed_password`: `TEXT` (хэш статически сгенерированного случайного пароля)
*   `permissions`: `TEXT[]` (набор строковых прав доступа вида `<область>:<действие>`)

> Управление пользователями выполняется только на этапе деплоя. В приложении отсутствуют эндпоинты и UI для создания, удаления или
> изменения учётных записей. Единственный способ заменить пароль — перегенерировать секреты и перезапустить сервис.


#### Права доступа и роли

`User.permissions` хранит массив строковых прав, который наполняется первоначальной миграцией и редактируется только вручную (через деплой/миграцию). При входе в систему сервис читает этот массив, добавляет его в JWT как claim `permissions`, и дальнейшие эндпоинты используют guard `RequirePermission` (FastAPI `Depends`) для проверки наличия требуемого права.

Допустимые права MVP:

| Право            | Назначение                                                                 | Используется в проверках |
|------------------|-----------------------------------------------------------------------------|---------------------------|
| `slots:read`     | Просмотр списка провайдеров, чтение конфигурации слотов                    | `GET /api/providers`, `GET /api/slots`, `GET /api/slots/{slot_id}` |
| `slots:write`    | Изменение конфигурации слотов и сброс статистики                           | `PUT /api/slots/{slot_id}`, `POST /api/slots/{slot_id}/reset_stats` |
| `stats:read`     | Просмотр статистики по слотам и глобальной статистики                      | `GET /api/stats/{slot_id}`, `GET /api/stats/global` |
| `settings:read`  | Просмотр глобальных настроек и статуса секретов                            | `GET /api/settings` |
| `settings:write` | Обновление глобальных настроек, вращение ingest-пароля, очистка медиа-кеша | `PUT /api/settings`, `POST /api/media/cache/purge` |

Предустановленные пользователи получают фиксированные наборы прав (редактируются только миграцией):

* `serg` — полный административный доступ: `slots:read`, `slots:write`, `stats:read`, `settings:read`, `settings:write`.
* `igor` — операционный доступ без изменения глобальных секретов: `slots:read`, `slots:write`, `stats:read`, `settings:read`.

Пользователи с правом `settings:write` автоматически удовлетворяют сценариям вращения ingest-пароля и очистки кеша; остальные эндпоинты отклоняют запросы с кодом `403` при отсутствии нужного права.



**Таблица `Slot`**
*   `id`: `TEXT` (Primary Key, одна из 15 предустановленных статических ingest-ссылок `slot-001` … `slot-015`)
*   `name`: `TEXT` (Имя, которое задает пользователь)
*   `user_id`: `INTEGER` (Foreign Key -> User)
*   `provider_id`: `TEXT` (ID провайдера из конфигурационного файла)
*   `operation_id`: `TEXT` (ID операции из конфигурационного файла)
*   `settings_json`: `TEXT` (JSON-строка с параметрами для AI-операции)
*   `last_reset_at`: `TIMESTAMP WITH TIME ZONE` (Дата последнего сброса статистики для этого слота)
*   `created_at`: `TIMESTAMP WITH TIME ZONE` (Момент первичного создания записи миграцией)
*   `updated_at`: `TIMESTAMP WITH TIME ZONE` (Момент последнего изменения настроек слота через API/UI)

> Для MVP доступно строго 15 ingest-слотов с фиксированными идентификаторами (`slot-001` … `slot-015`). Первая миграция базы данных
> создаёт эти записи один раз на всю платформу и формирует глобальный пул ingest-URL. Новые пользователи используют те же 15
> записей — `id` не дублируются и не пересоздаются. Поле `user_id` указывает, за кем закреплён слот; если слот свободен, значение
> `NULL`. Повторная настройка выполняется поверх существующей записи: `id` остаётся неизменным, а привязанная ingest-ссылка
> сохраняется на всём сроке жизни платформы.


**Таблица `Job`**
*   `id`: `UUID` (Primary Key)
*   `slot_id`: `TEXT` (Foreign Key -> Slot)
*   `status`: `TEXT` (enum: `pending`, `processing`)
*   `is_finalized`: `BOOLEAN`
*   `failure_reason`: `TEXT` (`timeout`, `provider_error`, `cancelled`; допускает `NULL` при успехе)
*   `provider_job_reference`: `TEXT` (nullable, единое поле для async/webhook идентификаторов внешнего провайдера)
*   `payload_path`: `TEXT` (nullable, путь к исходному ingest-файлу во временном хранилище)
*   `result_inline_base64`: `TEXT` (nullable, base64-представление последнего успешного изображения)
*   `result_file_path`: `TEXT` (nullable, путь к итоговому файлу, если он сохранён на диск)
*   `result_mime_type`: `TEXT` (nullable, MIME результата)
*   `result_size_bytes`: `INTEGER` (nullable, размер результата в байтах)
*   `result_checksum`: `TEXT` (nullable, контрольная сумма для валидации содержимого)
*   `created_at`: `TIMESTAMP WITH TIME ZONE`
*   `updated_at`: `TIMESTAMP WITH TIME ZONE`
*   `finalized_at`: `TIMESTAMP WITH TIME ZONE` (nullable, момент фиксации финального состояния)

`Job.status` отражает промежуточное состояние обработки. Как только API достигает дедлайна `T_sync_response` и возвращает 504, запись обновляется с `is_finalized = true`, `failure_reason = 'timeout'`, после чего дополнительные попытки не планируются. Очередь в PostgreSQL остаётся единственным механизмом постановки и back-pressure: воркеры берут задачи запросом `SELECT … FOR UPDATE SKIP LOCKED` и переводят запись в `status = 'processing'` без дополнительных локов или счётчиков.

Итоговое изображение хранится непосредственно в полях `result_*` текущей записи `Job`. Очистка результатов выполняется по TTL 72 часов: хранится только последний успешный ответ, который удаляется после истечения срока или перезаписывается при новом запуске. Если требуется предоставить итоговое изображение по публичной ссылке (например, для скачивания из UI), воркер дополнительно создаёт запись в `media_object`, но TTL финального результата определяется настройкой `processed_media_ttl_hours`, а не отдельным механизмом продления.

Взаимодействие с `media_object` остаётся прежним: если провайдер требует публичные ссылки, воркер регистрирует файл через `media_object`, а поле `result_file_path` хранит относительный путь до итогового изображения. При таймауте API задача получает `failure_reason = 'timeout'`, воркер отменяет активный запрос, удаляет временные файлы и помечает связанные `media_object` к немедленному удалению.



**Таблица `ProcessingLog`**
*   `id`: `INTEGER` (Primary Key)
*   `slot_id`: `TEXT` (Foreign Key -> Slot)
*   `created_at`: `TIMESTAMP WITH TIME ZONE` (Время получения ingest-запроса)
*   `status`: `TEXT` (`SUCCESS`, `ERROR`, `TIMEOUT`)
*   `response_time_ms`: `INTEGER` (Время ответа в миллисекундах)
*   `cost`: `REAL` (Стоимость операции, если применимо)
*   `error_message`: `TEXT` (Сообщение об ошибке)

`ProcessingLog.status = 'TIMEOUT'` соответствует задачам с `failure_reason = 'timeout'`; `ERROR` агрегирует `provider_error` и `cancelled`
(с указанием первопричины в `error_message`).


**Таблица `media_object`**
* id (UUID, PK)
* path (TEXT) — путь к файлу в MEDIA_ROOT
* mime (TEXT)
* size_bytes (INTEGER)
* created_at (TIMESTAMPTZ)
* expires_at (TIMESTAMPTZ)
* job_id (UUID, опционально) — связь с задачей обработки

Поле `expires_at` задаёт срок жизни временной ссылки на медиа-файл: оно заполняется при вызове `POST /api/media/register`,
используется проверкой доступа в `GET /public/media/{id}` и определяет, когда воркер и плановая очистка должны удалить
просроченные файлы. Значение вычисляется как момент регистрации + `MEDIA_PUBLIC_LINK_TTL_SEC = clamp(T_sync_response, 45, 60)` секунд.

Временные ссылки не продлеваются. Если ссылка утратила актуальность, администратор повторно вызывает `POST /api/media/register`
и получает новую запись `media_object`. Для файлов, связанных с активной задачей (`job_id` не `null`), воркеры отслеживают,
что провайдер скачал файл до истечения вычисленного TTL; по достижении дедлайна задача получает `failure_reason = 'timeout'`, а временные данные
удаляются без дополнительных действий.

После наступления `expires_at` запись `media_object` переводится в состояние `expired` и попадает в очередь автоочистки: фоновый
GC удаляет файл и помечает запись как `deleted` без участия воркеров или повторных попыток продления.

> **Примечание о хранении результата и `media_object`:**
>
> | Сценарий | Где хранится файл/данные | TTL | Нужно ли создавать `media_object` |
> | --- | --- | --- | --- |
> | Итоговое изображение, выдаваемое клиенту или отображаемое в UI | Поля `Job.result_*` (`result_inline_base64` или `result_file_path` в `MEDIA_ROOT/results`) | `processed_media_ttl_hours` (72 часа) либо перезапись при новом успешном запуске | Только если нужен публичный URL; при хранении результата для API запись `media_object` не обязательна |
> | Временная ссылка для провайдера (Turbotext и т. п.) или тестовых загрузок | Запись в `media_object` + файл в `MEDIA_ROOT/tmp` | `MEDIA_PUBLIC_LINK_TTL_SEC = clamp(T_sync_response, 45, 60)` секунд; по истечении срока ссылка удаляется без продления | Да, это основной механизм получения публичного URL |
> | Шаблонное/референсное изображение | Запись в `template_media` + файл в `MEDIA_ROOT/templates` | Не имеет TTL, удаляется вручную | Нет, `media_object` не используется |
>
> Таким образом, итог хранится в полях `Job.result_*`, а `media_object` обслуживает только временные публичные ссылки или дополнительную публикацию файла.

## API глобальных настроек и управление секретами

### GET /api/settings

Возвращает текущие глобальные настройки платформы. Требует авторизованного пользователя с правом `settings:read` (см. раздел «Права доступа и роли» и UI «Страница настроек»). Ответ 200 OK содержит JSON следующей структуры:

```json
{
  "dslr_password": {
    "is_set": true,
    "updated_at": "2024-05-14T12:30:00Z",
    "updated_by": "serg"
  },
  "provider_keys": {
    "gemini": {
      "is_configured": true,
      "updated_at": "2024-05-10T08:00:00Z",
      "updated_by": "serg"
    },
    "turbotext": {
      "is_configured": false,
      "updated_at": null,
      "updated_by": null
    }
  },
  "ingest": {
    "sync_response_timeout_sec": 48,
    "ingest_ttl_sec": 48
  },
  "media_cache": {
    "processed_media_ttl_hours": 72,
    "public_link_ttl_sec": 48
  }
}
```

Если отдельные значения не заданы, соответствующие поля возвращаются со значением `null` или булевым `false`. API никогда не возвращает открытые секреты — UI отображает только факт наличия значения и метаданные об обновлении. Для провайдера, который требует дополнительных не секретных параметров (например, `project_id`), ответ может дополнительно содержать их в явном виде.

### PUT /api/settings

Обновляет глобальные настройки. Требуется право `settings:write` (см. раздел «Права доступа и роли»). Запрос принимает JSON, в котором поля совпадают по структуре с ответом `GET /api/settings`, но для секретов передаётся вложенный объект `value`:

```json
{
  "dslr_password": { "value": "new-password" },
  "provider_keys": {
    "gemini": { "api_key": "AIza...", "project_id": "photochanger-prod" }
  },
  "ingest": { "sync_response_timeout_sec": 52 }
}
```

Необязательные поля можно опускать — сервер обновляет только переданные значения. Успешный ответ `200 OK` возвращает структуру, идентичную `GET /api/settings` (без раскрытия секретов). Разделы `ingest` и `media_cache` отражают вычисленные значения TTL (`sync_response_timeout_sec`, `ingest_ttl_sec`, `public_link_ttl_sec`, `processed_media_ttl_hours`) и служат для информирования UI: `public_link_ttl_sec = clamp(T_sync_response, 45, 60)`, `ingest_ttl_sec = min(T_sync_response, public_link_ttl_sec)`, а `processed_media_ttl_hours = 72`. Эти параметры не меняются напрямую через API, кроме явной настройки `sync_response_timeout_sec`. При использовании дискового хранения в `Job.result_file_path` поле `processed_media_ttl_hours` задаёт срок хранения файла для диагностики; в текущем MVP результат очищается автоматически по истечении этого срока (72 часа).

### Кнопка «Очистить мультимедиа кеш»

Кнопка на странице настроек вызывает `POST /api/media/cache/purge`. Эндпоинт требует права `settings:write` (см. раздел «Права доступа и роли») и принимает опциональное тело запроса:

```json
{
  "scope": "full"
}
```

Поле `scope` может принимать значения:

* `full` (по умолчанию) — планирует немедленную очистку: удаляются просроченные `media_object`, а также файлы, на которые более не ссылается ни одна запись `Job.result_file_path`.
* `media_objects` — ограничивает выполнение очисткой только временных `media_object` (папка `MEDIA_ROOT/tmp`).

В обоих режимах актуальные данные (`Job.result_*`) остаются нетронутыми: эндпоинт не удаляет результат последнего успешного запуска.

`template_media` и другие постоянные ресурсы очистка не затрагивает — они остаются в системе независимо от выбранного режима.

Ответ: `202 Accepted` с телом

```json
{
  "status": "queued_for_gc",
  "scope": "full",
  "job_id": "gc-2024-05-14T12:31:00Z",
  "expires_cutoff": "2024-05-14T12:30:59Z"
}
```

`job_id` — идентификатор фонового задания, `expires_cutoff` — момент времени, до которого будут очищены сущности (обычно `now()` на момент постановки). После завершения фонового задания в системные метрики отправляется счётчик `purged_entities` с разбивкой по типам (`job_results_files`, `media_objects`) и объёму в байтах. UI получает только факт постановки джоба и может периодически опрашивать мониторинг при необходимости.

### Требования к хранению и шифрованию глобальных настроек

* Таблица `app_settings` реализована как единое key-value хранилище: `key` (TEXT, PK), `value_json` (JSONB), `is_secret` (BOOLEAN, default false), `updated_at` (TIMESTAMPTZ), `updated_by` (INTEGER, FK → User). Все настройки, включая чувствительные, представлены JSON-структурами, поэтому отдельные колонки не используются. Для секретов и хэшей `value_json` сериализуется в виде объекта с метаданными, а `is_secret = true` сигнализирует прикладному коду, что значение нельзя возвращать в API целиком.
* DSLR-пароль хранится только в виде хэша `Argon2id` с индивидуальной солью в записи `app_settings` с ключом `"ingest.dslr_password"`. Структура `value_json` для этой записи: `{ "hash": <base64>, "salt": <base64>, "version": 1, "updated_at": <timestamp>, "updated_by": <user_id> }`. При сохранении нового пароля в `PUT /api/settings` сервер перехеширует значение, обновит запись и удалит исходный plaintext сразу после применения. Ответ `GET /api/settings` формируется на основании признака `hash IS NOT NULL` и метаданных из `value_json` (UI показывает только `is_set`, `updated_at`, `updated_by`).
* API-ключи провайдеров сохраняются в таблице `provider_secret` и шифруются алгоритмом AES-256-GCM; мастер-ключ шифрования берётся из переменной окружения `SETTINGS_MASTER_KEY`. Структура таблицы:
  * `id` (SERIAL, PK)
  * `provider_id` (TEXT, уникальный)
  * `encrypted_payload` (BYTEA)
  * `nonce` (BYTEA)
  * `version` (INTEGER, default 1)
  * `updated_at` (TIMESTAMPTZ)
  * `updated_by` (INTEGER, FK → User)
  * `has_secret` (BOOLEAN, default false) — признак наличия расшифровываемого ключа (используется в `GET /api/settings`)
* Значения TTL (`processed_media_ttl_hours`, `public_link_ttl_sec`) и другие нечувствительные параметры хранятся в `app_settings` с ключами `media.processed_ttl_hours` и `media.public_link_ttl_sec`. Для таких записей `is_secret = false`, а `value_json` содержит примитив (`integer`) или объект с описанием параметра. Настройка `media.processed_ttl_hours` применима только при использовании файлового варианта `Job.result_file_path`; `media_object` по-прежнему управляется значением `media.public_link_ttl_sec`. `template_media` хранится без TTL и очищается вручную. Если для удобства UI требуется отображать метаданные провайдеров без расшифровки (`project_id`, `region` и т. п.), используются отдельные записи `provider.<id>.<field>` с `is_secret = false`.
* Таймаут синхронного ожидания хранится в `app_settings["ingest.sync_response_timeout_sec"]`. После обновления значения сервис пересчитывает производные TTL (`media.ingest_ttl_sec`, `media.public_link_ttl_sec`) через `DeadlineGuard`.
* Доступ к чтению и расшифровке секретов предоставляется только слоям с правами `settings:read`/`settings:write`. Логирование секретов запрещено, в логах допускается только информация о наличии/отсутствии значения и времени обновления.

**Конфигурационные файлы**
Данные о Провайдерах (`Providers`) и их Операциях (`Operations`) будут храниться в статических конфигурационных файлах (например, `providers.json`), чтобы избежать усложнения схемы БД.

### Схема конфигурации провайдеров и параметров слота

Конфигурация разделена на два слоя:

1. **`configs/providers.json`** — статический каталог провайдеров и поддерживаемых операций. Файл публикуется веб-сервером как статический ресурс (например, `/static/providers.json`), поэтому UI загружает именно его для построения форм выбора и валидации параметров. Бэкенд использует тот же локальный файл при проверке запросов и формировании исходящих обращений к провайдерам. Флаг `requires_public_media` в конфигурации сигнализирует фронтенду, что для такого провайдера загрузчик должен предлагать только MIME из `MEDIA_ALLOWED_MIME` (т. е. JPEG/PNG/WEBP) и заранее блокировать HEIC/HEIF.
2. **`Slot.settings_json`** — сериализованное представление параметров операции, которые пользователь выбрал при настройке слота.

#### Формат `configs/providers.json`

```json
{
  "providers": [
    {
      "id": "gemini",
      "title": "Gemini",
      "ingest": {
        "max_parallel_jobs": 4,
        "timeout_sec": 48,
        "allowed_mime": [
          "image/jpeg",
          "image/png",
          "image/webp",
          "image/heic",
          "image/heif"
        ],
        "max_file_size_mb": 20
      },
      "operations": [
        "style_transfer",
        "image_edit",
        "identity_transfer"
      ]
    },
    {
      "id": "turbotext",
      "title": "TurboText",
      "ingest": {
        "max_parallel_jobs": 2,
        "timeout_sec": 48,
        "allowed_mime": [
          "image/jpeg",
          "image/png",
          "image/webp"
        ],
        "max_file_size_mb": 15,
        "requires_public_media": true
      },
      "operations": [
        "style_transfer",
        "image_edit",
        "identity_transfer"
      ]
    }
  ],
  "operations": {
    "style_transfer": {
      "title": "Style Transfer",
      "description": "Перенос художественного стиля между изображениями: Gemini использует эталонное фото, Turbotext — целевое + стилевое.",
      "required_settings": {
        "common": ["prompt"],
        "per_provider": {
          "gemini": ["reference_media_id"],
          "turbotext": ["target_media_id", "style_media_id"]
        }
      },
      "provider_overrides": {
        "gemini": { "endpoint": "/v1beta/models/gemini-image:transferStyle" },
        "turbotext": {
          "endpoint": "/api_ai/mix_images",
          "field_map": {
            "url_image_target": { "from": "template_media", "setting": "target_media_id" },
            "url": { "from": "template_media", "setting": "style_media_id" },
            "content": { "from": "settings", "setting": "prompt" }
          },
          "queue_based": true,
          "webhook_supported": true
        }
      },
      "settings_schema": {
        "type": "object",
        "properties": {
          "prompt": { "type": "string", "maxLength": 2000 },
          "reference_media_id": { "type": "string", "format": "uuid" },
          "style_strength": { "type": "number", "minimum": 0, "maximum": 1, "default": 0.65 },
          "target_media_id": { "type": "string", "format": "uuid" },
          "style_media_id": { "type": "string", "format": "uuid" },
          "output": {
            "type": "object",
            "properties": {
              "format": { "type": "string", "enum": ["jpeg", "png", "webp"], "default": "jpeg" },
              "max_side_px": { "type": "integer", "minimum": 256, "maximum": 4096, "default": 2048 }
            }
          }
        },
        "required": ["prompt"],
        "oneOf": [
          { "required": ["reference_media_id"] },
          { "required": ["target_media_id", "style_media_id"] }
        ],
        "additionalProperties": false
      }
    },
    "image_edit": {
      "title": "Image Edit",
      "description": "Локальное редактирование исходного изображения по текстовому описанию с поддержкой image-to-image.",
      "required_settings": {
        "common": ["prompt"],
        "per_provider": {
          "turbotext": ["source_media_id"]
        }
      },
      "provider_overrides": {
        "gemini": {
          "endpoint": "/v1beta/models/gemini-image:edit",
          "media_parts": [
            { "id": "ingest_media", "from": "ingest_request" }
          ]
        },
        "turbotext": {
          "endpoint": "/api_ai/generate_image2image",
          "field_map": {
            "url": { "from": "media_object", "setting": "source_media_id" },
            "content": { "from": "settings", "setting": "prompt" },
            "strength": { "from": "settings", "setting": "strength" },
            "seed": { "from": "settings", "setting": "seed" },
            "scale": { "from": "settings", "setting": "scale" },
            "negative_prompt": { "from": "settings", "setting": "negative_prompt" },
            "original_language": { "from": "settings", "setting": "original_language" }
          },
          "queue_based": true,
          "webhook_supported": true
        }
      },
      "settings_schema": {
        "type": "object",
        "properties": {
          "prompt": { "type": "string", "maxLength": 2000 },
          "guidance_scale": { "type": "number", "minimum": 0, "maximum": 20, "default": 7.5 },
          "source_media_id": { "type": "string", "format": "uuid" },
          "strength": { "type": "integer", "minimum": 0, "maximum": 80, "default": 40 },
          "seed": { "type": "integer", "minimum": 1, "maximum": 10000000000 },
          "scale": { "type": "number", "minimum": 0.1, "maximum": 20, "default": 7.5 },
          "negative_prompt": { "type": "string", "maxLength": 1000 },
          "original_language": { "type": "string", "default": "ru" },
          "output": {
            "type": "object",
            "properties": {
              "format": { "type": "string", "enum": ["jpeg", "png", "webp"], "default": "png" },
              "quality": { "type": "integer", "minimum": 1, "maximum": 100, "default": 100 }
            }
          }
        },
        "required": ["prompt"],
        "additionalProperties": false
      }
    },
    "identity_transfer": {
      "title": "Identity Transfer",
      "description": "Замена или совмещение лица между изображениями: Gemini работает через compose, Turbotext — через deepfake_photo.",
      "required_settings": {
        "per_provider": {
          "gemini": ["base_media_id", "overlay_media_id"],
          "turbotext": ["subject_media_id", "face_media_id"]
        }
      },
      "provider_overrides": {
        "gemini": {
          "endpoint": "/v1beta/models/gemini-image:compose"
        },
        "turbotext": {
          "endpoint": "/api_ai/deepfake_photo",
          "field_map": {
            "url": { "from": "template_media", "setting": "subject_media_id" },
            "url_image_target": { "from": "template_media", "setting": "face_media_id" },
            "face_restore": { "from": "settings", "setting": "face_restore" }
          },
          "queue_based": true,
          "webhook_supported": true
        }
      },
      "settings_schema": {
        "type": "object",
        "properties": {
          "prompt": { "type": "string", "maxLength": 2000 },
          "base_media_id": { "type": "string", "format": "uuid" },
          "overlay_media_id": { "type": "string", "format": "uuid" },
          "blend_mode": { "type": "string", "enum": ["alpha", "seamless", "face_swap"], "default": "face_swap" },
          "alignment": {
            "type": "object",
            "properties": {
              "face_landmarks": { "type": "boolean", "default": true },
              "scale": { "type": "number", "minimum": 0.1, "maximum": 4, "default": 1 }
            }
          },
          "subject_media_id": { "type": "string", "format": "uuid" },
          "face_media_id": { "type": "string", "format": "uuid" },
          "face_restore": { "type": "boolean", "default": false },
          "output": {
            "type": "object",
            "properties": {
              "format": { "type": "string", "enum": ["jpeg", "png"], "default": "jpeg" },
              "quality": { "type": "integer", "minimum": 1, "maximum": 100, "default": 92 }
            }
          }
        },
        "oneOf": [
          { "required": ["base_media_id", "overlay_media_id"] },
          { "required": ["subject_media_id", "face_media_id"] }
        ],
        "additionalProperties": false
      }
    }
  }
}
```

`ingest.allowed_mime` для каждого провайдера обязан в точности повторять фактические ограничения входящего ingest-потока и лимиты соответствующего провайдера. Любые изменения списка допустимых форматов нужно синхронно вносить и в эту конфигурацию, и в разделы, описывающие ingest-валидацию и требования внешних API.

Ключи `provider_overrides` фиксируют различия в интеграции: URL конечной точки, допустимые параметры, ограничения таймаута. Для операций,
требующих передачи локальных файлов, `media_parts` описывает, какие бинарные данные подставляются в запрос провайдера (например,
`image_edit` для Gemini получает `ingest_media` прямо из входящего запроса). Источник бинарных данных/URL теперь явный: `from: "media_object"`
используется для временных ссылок с TTL, а `from: "template_media"` — для постоянных шаблонов. При необходимости воркер временно регистрирует
шаблон в публичном хранилище, но исходный файл остаётся в каталоге `template_media`. Для Turbotext `field_map` указывает соответствие полей
формы (`url`, `url_image_target`, `content`, `face_restore` и т. д.) значениям из настроек слота и выбранному источнику медиа. Поле
`source_media_id` хранит идентификатор временной записи в `media_object`; TTL ссылки совпадает с `T_public_link_ttl = clamp(T_sync_response, 45, 60)` и покрывает только пользовательское окно ожидания. Если предпросмотр нужен дольше, администратор повторно загружает файл через `POST /api/media/register`, иначе ссылка истечёт перед запуском ingest. Общие свойства
`settings_schema` описывают обязательные поля, которые должны быть валидированы на бэкенде при сохранении слота, а `required_settings`
фиксирует как общие требования, так и провайдер-специфичные обязательные поля и источник медиа.

#### Маппинг `Slot`

* `provider_id` — значение поля `providers[].id`.
* `operation_id` — одно из значений `operations` (на уровне провайдера).
* `settings_json` — JSON-объект, удовлетворяющий `settings_schema` соответствующей операции. На бэкенде хранится сериализованный JSON,
  где ссылки на долговечные шаблоны сохраняются как идентификаторы `template_media.id`, а краткоживущие файлы и предпросмотры продолжают
  ссылаться на `media_object.id`. Операции явно указывают требуемый источник в `provider_overrides`/`media_parts`.

Пример значения `settings_json` для слота Gemini c операцией `identity_transfer`:

```json
{
  "prompt": "Сменить фон на корпоративный стиль",
  "base_media_id": "b7a09f84-7560-4a7b-9303-2b41a6d359f3",
  "overlay_media_id": "3ad89908-0df1-4f1e-b3e9-586eea730d21",
  "blend_mode": "face_swap",
  "alignment": { "face_landmarks": true, "scale": 1.1 },
  "output": { "format": "jpeg", "quality": 90 }
}
```

Пример значения `settings_json` для слота Gemini c операцией `image_edit` (исходное фото приходит во входящем ingest‑POST, в конфигурации остаются только параметры генерации):

```json
{
  "prompt": "Осветлить лицо и пригладить фон",
  "guidance_scale": 6.5,
  "output": { "format": "png", "quality": 95 }
}
```

На UI параметры собираются на основании `needs` (промпт, первое/второе изображение) и валидируются против схемы операции. При сохранении:

1. Шаблонные изображения (стили, лица и т. д.) уходят в `POST /api/template-media/register`; ответ содержит `template_media_id`,
   который сохраняется в `slot_template_binding` и затем подставляется в `settings_json`.
2. Временные файлы (тестовое фото, предпросмотр, любые `source_media_id`) загружаются через `POST /api/media/register`; UI
   получает `media_object.id` и использует его только как временный идентификатор.
3. Перед сохранением слота бекенд формирует объект по схеме и сериализует JSON в `Slot.settings_json`. Если требуется оперировать `media_object.id` позже стандартного окна `T_public_link_ttl`, файл необходимо загрузить повторно ближе к запуску ingest; продление ссылок не поддерживается.
4. При старте ingest воркер не продлевает временные `media_object` (включая `source_media_id`): интеграции должны скачать файл в течение базового TTL, иначе задача истечёт и будет перезапущена пользователем.

## Стек
*   **Бэкенд:** FastAPI
*   **База данных:** PostgreSQL
*  **Очередь задач:** Постоянная очередь в PostgreSQL (таблица `job` + `SELECT … FOR UPDATE SKIP LOCKED` воркеров)
*   **Фронтенд:** HTMX, VanillaJS

# API Спецификация
## Внутренний API (для Frontend)
API для взаимодействия с веб-интерфейсом построен на принципах REST. Все защищённые эндпоинты требуют передачи заголовка `Authorization: Bearer <JWT>`; токен действует 60 минут с момента выдачи и должен быть обновлён повторным вызовом `/api/login` после истечения срока. Ответы об ошибках имеют единый формат:

```json
{
  "error": {
    "code": "<machine_readable_code>",
    "message": "Человекочитаемое описание проблемы",
    "details": { "field": "optional context" }
  }
}
```

Общие коды состояния: `400` — ошибка валидации, `401` — неавторизовано/истёкший токен, `403` — недостаточно прав, `404` — ресурс не найден, `409` — конфликт (например, слот уже существует), `422` — семантическая ошибка тела запроса, `500` — внутренняя ошибка сервера.

### Аутентификация
JWT, выдаваемый платформой, содержит claim `permissions` с массивом прав из `User.permissions`. Каждый защищённый эндпоинт подключает зависимость `RequirePermission` и сравнивает требуемое право с этим массивом, возвращая `403`, если право отсутствует.
**`POST /api/login`**

* **Назначение:** Вход пользователя и получение JWT.
* **Аутентификация:** не требуется.
* **Тело запроса:**
  ```json
  {
    "username": "admin",
    "password": "secret"
  }
  ```
* **Успешный ответ (`200 OK`):**
  ```json
  {
    "access_token": "<jwt>",
    "token_type": "bearer",
    "expires_in_sec": 3600
  }
  ```
* **Ошибки:** `400` (некорректное тело), `401` (неверные учётные данные), `429` (слишком частые попытки).

#### Статические пользователи и секреты
- В веб-интерфейсе доступны только две учётные записи: `serg` и `igor`. Их случайные пароли генерируются в процессе деплоя и
  сохраняются в файле `secrets/runtime_credentials.json`, который добавлен в `.gitignore` и не версионируется.
- Наборы прав для этих пользователей задаются в `User.permissions` (см. раздел «Права доступа и роли»), попадают в JWT claim `permissions` и проверяются зависимостью `RequirePermission` для каждого защищённого эндпоинта.
- JWT выдаётся только для указанных предустановленных пользователей; сценарии регистрации, восстановления доступа и смены пароля
  намеренно отсутствуют.
- Ingest-эндпоинты дополнительно защищены отдельным случайным паролем, который хранится в записи `app_settings` с ключом `"ingest.dslr_password"` (JSON содержит хэш и соль) и передаётся в теле POST-запроса вместе с фотографией. Plaintext хранится только на стороне клиента DSLR.
- Ротация ingest-пароля выполняется через интерфейс «Настройки» (`PUT /api/settings`), который перехеширует значение и обновляет метаданные (`updated_at`, `updated_by`); перезапуск сервиса или ручное редактирование файлов не требуется.

### Провайдеры
**`GET /api/providers`**

* **Назначение:** Получить короткий справочник провайдеров (идентификатор и отображаемое имя) для заполнения выпадающих списков UI; расширенные данные о провайдерах и операциях UI читает из `configs/providers.json`, опубликованного как статический ресурс.
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `slots:read` (см. раздел «Права доступа и роли»).
* **Параметры запроса:** отсутствуют; пагинация не применяется из-за ограниченного числа записей.
* **Успешный ответ (`200 OK`):**
  ```json
  {
    "providers": [
      { "id": "gemini", "name": "Gemini" },
      { "id": "turbotext", "name": "TurboText" }
    ]
  }
  ```
* **Ошибки:** стандартные (`401`, `403`, `500`).

### Слоты
**`GET /api/slots`**

* **Назначение:** Получить список всех 15 преднастроенных слотов платформы (глобальный пул) и их актуальные настройки.
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `slots:read`.
* **Пагинация:** не применяется (возвращается ровно 15 записей); фронтенд может выполнять клиентскую пагинацию/фильтрацию.
* **Фильтрация:** query-параметры `provider_id`, `operation_id`, `search` опциональны и используются для сокращения набора возвращаемых слотов.
* **Успешный ответ (`200 OK`):**
  ```json
  {
    "data": [
      {
        "id": "slot-001",
        "name": "Fashion Studio",
        "provider_id": "gemini",
        "operation_id": "style_transfer",
        "settings_json": {
          "prompt": "Передай стиль глянцевого журнала",
          "reference_media_id": "0a403f97-312f-4fc5-9f01-7de121c9a9d7",
          "output": {
            "format": "jpeg",
            "max_side_px": 2048
          }
        },
        "last_reset_at": "2024-04-22T09:15:00Z",
        "created_at": "2024-03-10T08:00:00Z",
        "updated_at": "2024-04-22T11:30:00Z"
      }
    ],
    "meta": {
      "total": 15
    }
  }
  ```
* **Ошибки:** `400` (некорректные параметры фильтрации), стандартные ошибки авторизации/доступа.
* **Примечание:** создание и удаление слотов недоступны — пользователь редактирует только предзагруженные идентификаторы. Ингест-ссылка вычисляется по шаблону `<BASE_URL>/ingest/{slot_id}` и не хранится как отдельное поле таблицы. Поля `*_media_id`, возвращаемые в `settings_json`, для шаблонов содержат идентификаторы `template_media`; временные вложения продолжают использовать `media_object.id`.

**`GET /api/slots/{slot_id}`**

* **Назначение:** Получить данные конкретного слота.
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `slots:read`.
* **Параметры:** `slot_id` (path).
* **Успешный ответ (`200 OK`):**
  ```json
  {
    "id": "slot-001",
    "name": "Fashion Studio",
    "provider_id": "gemini",
    "operation_id": "style_transfer",
    "settings_json": {
      "prompt": "Передай стиль глянцевого журнала",
      "reference_media_id": "0a403f97-312f-4fc5-9f01-7de121c9a9d7",
      "output": {
        "format": "jpeg",
        "max_side_px": 2048
      }
    },
    "last_reset_at": "2024-04-22T09:15:00Z",
    "created_at": "2024-03-10T08:00:00Z",
    "updated_at": "2024-04-22T11:30:00Z"
  }
  ```
* **Ошибки:** `404` (слот не найден), стандартные ошибки авторизации.

**`PUT /api/slots/{slot_id}`**

* **Назначение:** Обновить настройки одного из статических слотов.
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `slots:write`.
* **Тело запроса:** должно содержать актуальную метку версии слота — либо полем `updated_at` (скопированным из последнего `GET`), либо сервер принимает аналогичное значение в заголовке `If-Match`. При использовании заголовка `If-Match` поле `updated_at` в теле можно опустить. При отсутствии метки запрос отклоняется с `400`.
  ```json
  {
    "name": "Fashion Studio",
    "provider_id": "gemini",
    "operation_id": "identity_transfer",
    "settings_json": {
      "prompt": "Скомбинировать исходник со стилевым",
      "base_media_id": "b7a09f84-7560-4a7b-9303-2b41a6d359f3",
      "overlay_media_id": "3ad89908-0df1-4f1e-b3e9-586eea730d21",
      "alignment": {"face_landmarks": true},
      "output": {"format": "jpeg", "quality": 92}
    },
    "updated_at": "2024-04-22T11:30:00Z"
  }
  ```
* **Успешный ответ (`200 OK`):**
  ```json
  {
    "id": "slot-001",
    "updated_at": "2024-04-22T11:45:12Z"
  }
  ```
* **Ошибки:** `400`/`422` (ошибка валидации), `404` (слот не найден), `409` (слот занят фоновой операцией или версия не совпала), стандартные ошибки авторизации. Для конфликта версий сервер сравнивает переданную метку (`updated_at` из тела или заголовок `If-Match`) с текущей сохранённой и, если они различаются, возвращает `409` с телом `{"error": "conflict", "message": "Slot slot-001 has newer version"}`.
* **Пример конфликта версий (`409 Conflict`):**
  ```http
  PUT /api/slots/slot-001 HTTP/1.1
  Authorization: Bearer <JWT>
  Content-Type: application/json
  If-Match: "2024-04-22T11:30:00Z"

  {
    "name": "Fashion Studio",
    "provider_id": "gemini",
    "operation_id": "identity_transfer",
    "settings_json": {
      "prompt": "Скомбинировать исходник со стилевым",
      "base_media_id": "b7a09f84-7560-4a7b-9303-2b41a6d359f3",
      "overlay_media_id": "3ad89908-0df1-4f1e-b3e9-586eea730d21",
      "alignment": {"face_landmarks": true},
      "output": {"format": "jpeg", "quality": 92}
    }
  }
  ```
  ```json
  {
    "error": "conflict",
    "message": "Slot slot-001 has newer version",
    "current_updated_at": "2024-04-22T11:45:12Z"
  }
  ```

**`POST /api/slots/{slot_id}/reset_stats`**

* **Назначение:** Обнулить статистику выбранного слота.
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `slots:write`.
* **Тело запроса:** отсутствует (передавайте пустой JSON `{}` для совместимости).
* **Успешный ответ:** `204 No Content`.
* **Ошибки:** `404` (слот не найден), `409` (выполняется сброс), стандартные ошибки авторизации.

### Шаблонные медиа

**`POST /api/template-media/register`**

* **Назначение:** Загрузить файл-шаблон и привязать его к конкретному слоту/полю.
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `slots:write`.
* **Тело запроса:** `multipart/form-data` с полями `file` (бинарный файл JPEG/PNG/WEBP/HEIC/HEIF), `slot_id` (TEXT), `setting_key`
  (TEXT, имя поля в `settings_json`) и опциональным `label` (TEXT). Чтобы заменить существующий шаблон, добавьте флаг `replace=true` —
  сервер удалит предыдущую привязку. Если слот ссылается на провайдера, у которого в `configs/providers.json` выставлено
  `requires_public_media=true`, сервер дополнительно ограничивает MIME: принимаются только значения из `MEDIA_ALLOWED_MIME`
  (т. е. `image/jpeg`, `image/png`, `image/webp`), остальные форматы приводят к ответу `415 Unsupported Media Type`.
* **Успешный ответ (`201 Created`):**
  ```json
  {
    "id": "4d4b522f-ec60-4d61-902c-3a0c5c6dc1f3",
    "slot_id": "slot-001",
    "setting_key": "style_media_id",
    "label": "Glamour reference",
    "mime": "image/jpeg",
    "size_bytes": 523891,
    "created_at": "2024-05-20T10:12:44Z"
  }
  ```
  Эндпоинт создаёт запись в `template_media`, обновляет `slot_template_binding` и возвращает идентификатор, который UI подставляет
  в `Slot.settings_json`.
* **Ошибки:** `400` (некорректный формат/размер файла), `401`/`403` (авторизация), `404` (слот не найден), `409` (конфликт привязок
  без `replace=true`).

**`DELETE /api/template-media/{id}`**

* **Назначение:** Удалить шаблон и отвязать его от слота по инициативе пользователя (кнопка «Убрать»).
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `slots:write`.
* **Параметры:** Path `id`; Query `slot_id` и `setting_key` — подтверждают, что удаляется верная привязка. Опционально `force=true`
  — удаляет файл даже если он закреплён за несколькими слотами.
* **Успешный ответ:** `204 No Content` (если файл больше не используется — запись и файл из `MEDIA_ROOT/templates` удаляются; при
  других привязках он остаётся, но связь с указанным слотом стирается).
* **Ошибки:** `404` (шаблон или привязка не найдены), `409` (попытка удалить используемый несколькими слотами без `force`).

### Статистика
**`GET /api/stats/{slot_id}`**

* **Назначение:** Получить детальную статистику по слоту.
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `stats:read`.
* **Параметры:**
  * Path: `slot_id`.
  * Query: `from` и `to` (ISO8601, ограничение диапазона — не более 31 дня), `group_by` (`hour`, `day`, `week`, дефолт `day`).
* **Сортировка:** группировки возвращаются в хронологическом порядке по возрастанию.
* **Пагинация:** не применяется (результат ограничен диапазоном дат).
* **Поля `summary`:**
  * `title` — текущее название слота, отдаётся для UI (если поле пустое, фронтенд отображает `slot_id`).
  * `success` — количество задач с `is_finalized = true` и `failure_reason = null` в выбранном диапазоне.
  * `timeouts` — количество задач с `failure_reason = 'timeout'` (безусловно завершённых по `T_sync_response`).
  * `provider_errors` — количество задач с `failure_reason = 'provider_error'`.
  * `cancelled` — количество задач с `failure_reason = 'cancelled'` (ручная отмена, сброс очереди).
  * `errors` — суммарное количество неуспешных задач (`timeouts + provider_errors + cancelled`).
  * `ingest_count` — общее число ingest-запросов (`success + errors`).
  * `avg_response_ms` и `p95_response_ms` — среднее и 95-й перцентиль времени ответа по успешным задачам.
  * `error_rate_percent` — доля ошибок, выраженная в процентах, округление до двух знаков после запятой.
  * `last_cost` — стоимость последней успешной задачи (может быть `null`), `total_cost` — суммарные расходы за период.
  * `last_reset_at` — момент последнего сброса статистики (ISO8601, `null`, если сбросов не было).
* **Успешный ответ (`200 OK`):**
  ```json
  {
    "slot_id": "slot-001",
    "range": { "from": "2024-04-01", "to": "2024-04-07", "group_by": "day" },
    "summary": {
      "title": "Fashion Portrait",
      "success": 42,
      "timeouts": 5,
      "provider_errors": 2,
      "cancelled": 1,
      "errors": 8,
      "ingest_count": 50,
      "avg_response_ms": 2150,
      "p95_response_ms": 3420,
      "error_rate_percent": 16.0,
      "last_cost": 0.48,
      "total_cost": 18.76,
      "last_reset_at": "2024-03-20T12:00:00Z"
    },
    "metrics": [
      {
        "period_start": "2024-04-01",
        "period_end": "2024-04-01",
        "success": 12,
        "timeouts": 1,
        "provider_errors": 0,
        "cancelled": 0,
        "errors": 1,
        "ingest_count": 13,
        "avg_response_ms": 2100,
        "p95_response_ms": 3300,
        "total_cost": 4.35
      }
    ]
  }
  ```
  * `summary` агрегирует показатели за период между `last_reset_at` (или `from`, если передан диапазон) и текущим моментом. `errors = timeouts + provider_errors + cancelled`, `ingest_count = success + errors`, `error_rate_percent` рассчитывается как `(errors / ingest_count) * 100` с округлением до двух знаков после запятой. `last_cost` указывает стоимость последнего успешного запуска (может быть `null`).
  * Каждый элемент `metrics` описывает выбранный интервал (`group_by`) и повторяет те же правила расчёта; `errors = timeouts + provider_errors + cancelled`, `total_cost` — сумма расходов за период, `p95_response_ms` считается только по успешным задачам.
* **Ошибки:** `400` (некорректный диапазон), `404` (слот не найден), стандартные ошибки авторизации.

**`GET /api/stats/global`**

* **Назначение:** Получить агрегированную статистику по всем слотам пользователя.
* **Аутентификация:** требуется `Authorization: Bearer <JWT>`; необходимо право `stats:read`.
* **Параметры:**
  * Query: `from`/`to` (ISO8601, максимум 90 дней), `group_by` (`day`, `week`, `month`, дефолт `week`).
  * Пагинация списка записей: `page` (>=1, дефолт 1), `page_size` (1–50, дефолт 10).
  * Сортировка: `sort_by` (`period_start`, `success`, `errors`, `ingest_count`, `avg_response_ms`, `p95_response_ms`, `total_cost`) и `sort_order` (`asc`/`desc`, дефолт `desc`).
  * Фильтры: `provider_id`, `slot_id` (опционально ограничивают агрегаты).
* **Успешный ответ (`200 OK`):**
  ```json
  {
    "summary": {
      "total_runs": 420,
      "timeouts": 32,
      "provider_errors": 20,
      "cancelled": 8,
      "errors": 60,
      "ingest_count": 480,
      "avg_response_ms": 2050,
      "p95_response_ms": 3350,
      "error_rate_percent": 12.5,
      "total_cost": 128.40
    },
    "data": [
      {
        "period_start": "2024-04-01",
        "period_end": "2024-04-07",
        "success": 84,
        "timeouts": 4,
        "provider_errors": 2,
        "cancelled": 0,
        "errors": 6,
        "ingest_count": 90,
        "avg_response_ms": 1980,
        "p95_response_ms": 3180,
        "total_cost": 31.8
      }
    ],
    "meta": {
      "page": 1,
      "page_size": 10,
      "total": 12
    }
  }
  ```
  `summary` агрегирует показатели за весь диапазон (`from`/`to` или дефолтные 90 дней). `total_runs` — сумма успешных обработок, `errors = timeouts + provider_errors + cancelled`, `ingest_count = total_runs + errors`, `error_rate_percent` рассчитывается так же, как в `/api/stats/{slot_id}`. Значения `total_cost` и `p95_response_ms` считаются по всем слотам, учитывая фильтры.
* **Ошибки:** `400` (некорректные параметры фильтров/пагинации), стандартные ошибки авторизации.

### Административный мониторинг очереди

Административный REST API предоставляет операторам платформы доступ к очереди задач в read-only режиме. Эндпоинты находятся за
JWT-аутентификацией (`Authorization: Bearer <JWT>`) и требуют права `stats:read`, так что внешний ingest-трафик не получает к ним
доступ.

**`GET /api/jobs`**

* **Назначение:** показать очередь и завершённые задачи с агрегированными дедлайнами и метриками из DeadlineGuard.
* **Фильтры и сортировка:**
  * `status` (`pending`/`processing`), `is_finalized` (`true`/`false`) — позволяют переключаться между активными и закрытыми
    задачами.
  * `failure_reason` (`timeout`, `provider_error`, `cancelled`) — выделяет конкретные причины неуспехов.
  * `slot_id` — отбирает задачи выбранного ingest-слота (`slot-001` … `slot-015`).
  * Пагинация `page`/`page_size` (1–100 записей) и сортировка `sort_by` (`created_at`, `expires_at`) + `sort_order`
    (`asc`/`desc`).
* **Структура ответа (`200 OK`):**
  * `data[]` — массив объектов `JobAdminView`.
  * `meta` — постраничная навигация (`page`, `page_size`, `total`).

Каждый `JobAdminView` состоит из трёх блоков:

* `job` — основная запись очереди (идентификатор, `slot_id`, `status`, `is_finalized`, `failure_reason`, ссылки на payload/result,
  временные метки), соответствующая контракту `Job`.
* `deadline` — агрегат DeadlineGuard (`expires_at`, `remaining_ms`, `is_expired`), отражающий единый дедлайн `Job.expires_at` и
  остаток времени.
* `metrics` — сводные тайминги: `queue_wait_ms`, `processing_ms`, `total_elapsed_ms`. Значения вычисляются на основе служебных
  отметок создания/обработки и помогают операторам отслеживать задержки.

**`GET /api/jobs/{job_id}`**

* **Назначение:** предоставить оператору подробную карточку задачи для разбора инцидентов (те же блоки `job` + `deadline` +
  `metrics`, дополненные полями конкретной записи).
* **Особенности:** маршрут read-only, использует те же дедлайны DeadlineGuard и не заменяет ingest API — изменения статуса задачи
  происходят только за счёт фоновых воркеров.

Эти эндпоинты используются административным UI и внутренними инструментами мониторинга, чтобы выявлять накопление задач, уходы в
таймаут и влияние параметров дедлайна без вмешательства в бизнес-логику ingest.


## Внешний API: Ingest (DSLR Remote Pro)
Этот эндпоинт предназначен для приёма `POST` запросов от программы DSLR Remote Pro. Будет сгенерировано 15 статических коротких ingest-ссылок, которые можно привязывать к слотам.

### POST /ingest/{slotId}
- **Метод и путь:** `POST /ingest/{slotId}`.
- **Назначение:** принять фотографию и метаданные от DSLR Remote Pro для дальнейшей обработки в соответствии с конфигурацией слота.
- **Авторизация:** глобальный пароль, передаваемый в теле (поле `password`). Сравнивается с хешем, сохранённым в записи `app_settings` `"ingest.dslr_password"`. Одно и то же значение используется для всех ingest-слотов.
- **slotId:** статический идентификатор ingest-слота (предзаданные значения `slot-001` … `slot-015`). Контракты фиксируют этот
  перечень значений, любые другие идентификаторы отклоняются ещё на уровне валидации клиента/шлюза с ответом `404` без передачи
  запроса дальше по пайплайну.

#### Тело запроса
- **Тип:** `multipart/form-data`.
- **Обязательные поля:**
  - `password` — строка. Проверяется на совпадение с глобальным Argon2-хешем из `app_settings` (`value_json.hash` в записи `"ingest.dslr_password"`); требуется непустое значение.
  - `fileToUpload` — бинарный файл изображения. Поддерживаемые форматы: JPEG, PNG, WEBP, HEIC, HEIF. Лимит размера конфигурируемый (значение по умолчанию ≤ 15 МБ, чтобы соответствовать строгим ограничениям провайдера с минимальным порогом). Дополнительные EXIF/метаданные не изменяются и сохраняются в исходном виде.
- **Опциональные текстовые поля:** `time`, `user_id`, `id`, `profile`, `status`, `hash`, `name`, `model`, `version` и другие возможные поля DSLR Remote Pro. Все они обрабатываются как best-effort метаданные: не валидируются, сохраняются как есть (например, в metadata задачи или логах) и не влияют на принятие решения.
- **Неизвестные поля:** любые дополнительные ключи допустимы, система не ограничивает их список и не пытается валидировать содержимое.
- **Несколько файлов:** если в форме передано несколько файлов, сервер выбирает первый файл с поддерживаемым MIME-типом; остальные игнорируются, но факт их наличия фиксируется в логах для диагностики.

#### Ответы
- **200 OK** — успешная обработка. Тело содержит бинарное изображение; фактический `Content-Type` обязан принадлежать перечню, зафиксированному в пункте&nbsp;5 «[Возврат бинарного тела в ingest](#ingest-binary-return)», и перечисляется в контракте и во всех проверках. Заголовки ответа: `Content-Type` (конкретное значение из списка поддерживаемых MIME), `Content-Length`, `Cache-Control: no-store`. Ответ возвращается синхронно, время ожидания ≤ 48–50 с. При превышении лимита ожидания клиент получит 504.
- **Ошибки:**
  - `400 Bad Request` — отсутствует обязательное поле (`password` или `fileToUpload`), передан неподдерживаемый тип данных в поле формы или нарушен формат `multipart/form-data`.
  - `401 Unauthorized` — пароль не совпал с глобальным ingest-паролем.
  - `413 Payload Too Large` — размер файла превысил установленный лимит.
  - `415 Unsupported Media Type` — MIME-тип файла вне списка поддерживаемых.
  - `429 Too Many Requests` — очередь задач для данного слота достигла лимита параллельных обработок.
  - `500 Internal Server Error` — внутренняя ошибка платформы.
  - `503 Service Unavailable` — адаптер провайдера недоступен или вернул временную ошибку.
  - `504 Gateway Timeout` — обработка не завершена в пределах синхронного окна ожидания (`failure_reason = 'timeout'`, воркер и очередь получают сигнал отмены).

**Структура ошибки:**
```json
{
  "error": {
    "code": "<snake_case>",
    "message": "<читаемое описание>",
    "details": { }
  }
}
```
`Content-Type: application/json`. Поле `code` стабильно и может использоваться клиентом для обработки ошибок; объект `details` опционален и при необходимости содержит дополнительную диагностику.

#### Ограничения и валидация
- Лимит размера файла конфигурируется (по умолчанию ≤ 15 МБ, согласовано с минимальным лимитом провайдеров). Превышение приводит к 413.
- Поддерживаемые MIME: `image/jpeg`, `image/png`, `image/webp`, `image/heic`, `image/heif`. Остальные значения вызывают 415.
  Для слотов, где провайдер требует публичные ссылки (`requires_public_media=true`), фактический список сужается до `MEDIA_ALLOWED_MIME`
  (JPEG/PNG/WEBP) — и UI, и сервер обязаны отклонять HEIC/HEIF до попытки загрузки в публичное хранилище.
- Синхронное ожидание результата ограничено ~48–50 с; превышение приводит к 504 и остановке дальнейшей выдачи результата по текущему запросу.
- На слот действует ограничение числа одновременно обрабатываемых задач; переполнение очереди возвращает 429.
- Неизвестные текстовые поля и дополнительные файлы сохраняются/логируются без модификаций и не влияют на валидацию.

#### Пример сырых полей от DSLR Remote Pro (для справки)
В пользовательском запросе должна быть передана исходная фотография, глобальный пароль и, опционально, некоторые другие поля. Пример пользовательского POST запроса для DSLR программы:

```json
{
  "timestamp": "2025-09-18T17:45:12.439171+00:00",
  "client": {
    "host": "127.0.0.1",
    "port": 1417
  },
  "method": "POST",
  "url": "http://localhost:8000/echo?session=42",
  "path": "/echo",
  "query_params": {
    "session": "42"
  },
  "headers": {
    "host": "localhost:8000",
    "content-type": "multipart/form-data; boundary=------------090306000104030805010400",
    "content-length": "53205",
    "expect": "100-continue"
  },
  "cookies": {},
  "content_type": "multipart/form-data; boundary=------------090306000104030805010400",
  "is_multipart": true,
  "form_text_fields": {
    "time": "1758217512",
    "user_id": "Acer",
    "id": "CY04N068111304S2L_00000001.",
    "profile": "C:\\Users\\Acer\\Documents\\PhotoboothImages\\setup_Serg.xml",
    "status": "C:\\Users\\Acer\\Documents\\PhotoboothImages\\screenSerg\\preview.jpg",
    "hash": "7b6c683e1d3fd29c8701791c54e3c12a236f5a5b",
    "name": "DESKTOP-K968T3F",
    "model": "Windows",
    "version": "3.30.2",
    "password": "123456"
  },
  "form_files": [
    {
      "field": "fileToUpload",
      "original_filename": "IMG_0003.JPG",
      "saved_as": "\\tmp\\fastapi_echo\\uploads\\20250918T174512Z_e6bf1d6c98c843d6aa4948d07f251c17.JPG",
      "content_type": "image/jpeg",
      "size_bytes": 51977,
      "is_image_jpeg": true
    }
  ]
}
```
Ответ при успехе: бинарный `image/jpeg`|`image/png`|`image/webp`|`image/heic`|`image/heif` (синхронно, short-poll ≤ `T_sync_response`; см. пункт&nbsp;5).
В ответе на этот запрос наш сервер должен отправить фотографию, обработанную AI моделью.

#### Пункт 5. Возврат бинарного тела в ingest {#ingest-binary-return}
- **Назначение требования:** обеспечить однозначный контракт на синхронный возврат результата AI-обработки.
- **Список MIME-типов:** `image/jpeg`, `image/png`, `image/webp`, `image/heic`, `image/heif`. Каждый тип обязательно перечисляется в ответе `POST /ingest/{slotId}` (см. раздел выше), в `contracts/openapi.yaml` (например, через `oneOf`/`anyOf` по `content`) и в соответствующих контрактных и e2e-тестах. Расширение набора допускается только через обновление брифа с синхронной правкой спецификаций и тестов.
- **Синхронизация артефактов:** любые изменения списка немедленно отражаются в автотестах (`tests/contracts/*`, e2e), документации клиента и чек-листах QA. Проверка на стороне ревью заключается в подтверждении, что все перечисленные типы покрыты в контрактах и тест-кейсах.

## API Turbotext
для работы с моделью Турботекст будут использоваться следующие методы:
- Микс-фото
- Замена объекта
- Замена лица
Описание api находится тут https://www.turbotext.ru/photo_ai/docs/info#section-2
Все запросы отправляются на url: https://www.turbotext.ru/api_ai

### Авторизация
Идентификацию пользователя организуйте посредством Bearer Token,
Пример CURL, данные с Headers запроса:
```http
Authorization: Bearer {APIKEY}
Content-Type: application/x-www-form-urlencoded
```

### Webhook

Если вы хотите запустить серию генераций вам необходимо использовать асинхронный метод генерации, для этого создаем webhook который сможет принимать и обрабатывать результаты генераций.

При обычном методе генерации, вы создаете очередь, затем с помощью номера очереди получаете результат генерации,

в асинхронном методе геннерации, вы создаете очередь добавив в пост данные:

`webhook=https://mysite.com/webhook_example.php`

Ответ на запрос будет такой:

`{"success":true,"asyncid":N} `, где N номер очереди, при получении ответа вы получите параметр asyncid с таким же значением.

Нейро-сервер после обработки вашего запроса, отправит вам на адрес который вы указали в параметре webhook POST данные с результатом генерации,
Формат данных точно такой же как и при получении вторым запросом.

Вы получите результат генерации на ваш WEBHOOK URL в формате JSON

пример получения результата на php:
```php
$result=file_get_contents('php://input');//входящий JSON результат`
$result_array=json_decode($result,1);//Результаты в массиве
```

### Метод Микс фото
Запрос на создании очереди
```http
/api_ai/mix_images HTTP/1.1
Host: turbotext.ru
Authorization: Bearer {APIKEY}
Content-Type: application/x-www-form-urlencoded
Content-Length: 0
```
do:create_queue
content - описание для усиления эффекта
url_image_target - фото на урл которое нужно обработать
url - фото на урл откуда используем стиль 

Ответ с данными очереди в формате JSON:
`{"success":true,"queueid":{QUEUEID}}`
Здесь `{QUEUEID}` - Номер нашей очереди, далее обращаемся за получением результата использую этот массив данных.
Теперь делаем запрос на получение результата:
```http
/api_ai/mix_images HTTP/1.1
Host: turbotext.ru
Authorization: Bearer {APIKEY}
Content-Type: application/x-www-form-urlencoded
Content-Length: 0
do:get_result
queueid:{QUEUEID} 
```

## API Gemini
### Ссылки на документацию 
Image generation: https://ai.google.dev/gemini-api/docs/image-generation#image_generation_text-to-image
Image understanding: https://ai.google.dev/gemini-api/docs/image-understanding
Files API guide: https://ai.google.dev/gemini-api/docs/files
File prompting strategies: https://ai.google.dev/gemini-api/docs/files#prompt-guide
### Описание API 
Image generation with Gemini (aka Nano Banana)
Multi-Image to Image (Composition & Style Transfer): Use multiple input images to compose a new scene or transfer the style from one image to another.

#### Passing images to Gemini
You can provide images as input to Gemini using two methods:
 1.   Passing inline image data: Ideal for smaller files (total request size less than 20MB, including prompts). 
 2.   Uploading images using the File API: Recommended for larger files or for reusing images across multiple requests. 

##### Passing inline image data
You can pass inline image data in the request to `generateContent`. You can provide image data as Base64 encoded strings or by reading local files directly (depending on the language). The following example shows how to read an image from a local file and pass it to `generateContent` API for processing.
Passing inline image data example:
```python
  from google.genai import types

  with open('path/to/small-sample.jpg', 'rb') as f:
      image_bytes = f.read()

  response = client.models.generate_content(
    model='gemini-2.5-flash',
    contents=[
      types.Part.from_bytes(
        data=image_bytes,
        mime_type='image/jpeg',
      ),
      'Caption this image.'
    ]
  )

  print(response.text)
```
You can also fetch an image from a URL, convert it to bytes, and pass it to `generateContent` as shown in the following examples:
```python
from google import genai
from google.genai import types

import requests

image_path = "https://goo.gle/instrument-img"
image_bytes = requests.get(image_path).content
image = types.Part.from_bytes(
  data=image_bytes, mime_type="image/jpeg"
)

client = genai.Client()

response = client.models.generate_content(
    model="gemini-2.5-flash",
    contents=["What is this image?", image],
)

print(response.text)
```

##### Uploading images using the File API
For large files or **to be able to use the same image file repeatedly, use the Files API**. 
The Gemini family of artificial intelligence (AI) models is built to handle various types of input data, including text, images, and audio. Since these models can handle more than one type or mode of data, the Gemini models are called multimodal models or explained as having multimodal capabilities.
This guide shows you how to work with media files using the Files API. The basic operations are the same for audio files, images, videos, documents, and other supported file types.

###### Upload a file
 Always use the Files API when the total request size (including the files, text prompt, system instructions, etc.) is larger than 20 MB.
The following code uploads a file and then uses the file in a call to `generateContent`.

```python 
from google import genai
client = genai.Client()
myfile = client.files.upload(file="path/to/sample.mp3")
response = client.models.generate_content(
    model="gemini-2.5-flash", contents=["Describe this audio clip", myfile]
)
print(response.text)
```
###### Get metadata for a file
You can verify that the API successfully stored the uploaded file and get its metadata by calling `files.get`.
```python
myfile = client.files.upload(file='path/to/sample.mp3')
file_name = myfile.name
myfile = client.files.get(name=file_name)
print(myfile)

```
###### List uploaded files
You can upload multiple files using the Files API. The following code gets a list of all the files uploaded:
```python
print('My files:')
for f in client.files.list():
    print(' ', f.name)
```
###### Delete uploaded files
Files are automatically deleted after 48 hours. You can also manually delete an uploaded file:
```python
myfile = client.files.upload(file='path/to/sample.mp3')
client.files.delete(name=myfile.name)
```

###### Usage info
You can use the Files API to upload and interact with media files. The Files API lets you store up to 20 GB of files per project, with a per-file maximum size of 2 GB. Files are stored for 48 hours. During that time, you can use the API to get metadata about the files, but you can't download the files. The Files API is available at no cost in all regions where the Gemini API is available.

#### Prompting with multiple images. 

You can provide multiple images in a single prompt by including multiple image Part objects in the contents array. These can be a mix of inline data (local files or URLs) and File API references.
```python
from google import genai
from google.genai import types

client = genai.Client()

# Upload the first image
image1_path = "path/to/image1.jpg"
uploaded_file = client.files.upload(file=image1_path)

# Prepare the second image as inline data
image2_path = "path/to/image2.png"
with open(image2_path, 'rb') as f:
    img2_bytes = f.read()

# Create the prompt with text and multiple images
response = client.models.generate_content(

    model="gemini-2.5-flash",
    contents=[
        "What is different between these two images?",
        uploaded_file,  # Use the uploaded file reference
        types.Part.from_bytes(
            data=img2_bytes,
            mime_type='image/png'
        )
    ]
)
print(response.text)
```
##### Style transfer
Example of Prompt template
```
Transform the provided photograph of [subject] into the artistic style of [artist/art style]. Preserve the original composition but render it with [description of stylistic elements].
```
Example of code 
```python
from google import genai
from google.genai import types
from PIL import Image
from io import BytesIO

client = genai.Client()

# Base image prompt: "A photorealistic, high-resolution photograph of a busy city street in New York at night, with bright neon signs, yellow taxis, and tall skyscrapers."
city_image = Image.open('/path/to/your/city.png')
text_input = """Transform the provided photograph of a modern city street at night into the artistic style of Vincent van Gogh's 'Starry Night'. Preserve the original composition of buildings and cars, but render all elements with swirling, impasto brushstrokes and a dramatic palette of deep blues and bright yellows."""

# Generate an image from a text prompt
response = client.models.generate_content(
    model="gemini-2.5-flash-image-preview",
    contents=[city_image, text_input],
)

image_parts = [
    part.inline_data.data
    for part in response.candidates[0].content.parts
    if part.inline_data
]

if image_parts:
    image = Image.open(BytesIO(image_parts[0]))
    image.save('city_style_transfer.png')
    image.show()
```

##### Combining multiple images
Provide multiple images as context to create a new, composite scene. This is perfect for product mockups or creative collages.
Example of prompt:
```prompt
"Create a professional e-commerce fashion photo. Take the blue floral dress
from the first image and let the woman from the second image wear it.
Generate a realistic, full-body shot of the woman wearing the dress, with
the lighting and shadows adjusted to match the outdoor environment.
Ensure the persons's face and features remain completely unchanged. "
```
Example of code:
```python
from google import genai
from google.genai import types
from PIL import Image
from io import BytesIO

client = genai.Client()

# Base image prompts:
# 1. Dress: "A professionally shot photo of a blue floral summer dress on a plain white background, ghost mannequin style."
# 2. Model: "Full-body shot of a woman with her hair in a bun, smiling, standing against a neutral grey studio background."
dress_image = Image.open('/path/to/your/dress.png')
model_image = Image.open('/path/to/your/model.png')

text_input = """Create a professional e-commerce fashion photo. Take the blue floral dress from the first image and let the woman from the second image wear it. Generate a realistic, full-body shot of the woman wearing the dress, with the lighting and shadows adjusted to match the outdoor environment. Ensure the persons's face and features remain completely unchanged. """

# Generate an image from a text prompt
response = client.models.generate_content(
    model="gemini-2.5-flash-image-preview",
    contents=[dress_image, model_image, text_input],
)

image_parts = [
    part.inline_data.data
    for part in response.candidates[0].content.parts
    if part.inline_data
]

if image_parts:
    image = Image.open(BytesIO(image_parts[0]))
    image.save('fashion_ecommerce_shot.png')
    image.show()
```
###### High-fidelity detail preservation
To ensure critical details (like a face or logo) are preserved during an edit, describe them in great detail along with your edit request.
Example prompt:
```template
Using the provided images, place [element from image 2] onto [element from
image 1]. Ensure that the features of [element from image 1] remain
completely unchanged. The added element should [description of how the
element should integrate].
```

#### Best Practices
To elevate your results from good to great, incorporate these professional strategies into your workflow.

   * **Be Hyper-Specific:** The more detail you provide, the more control you have. Instead of "fantasy armor," describe it: "ornate elven plate armor, etched with silver leaf patterns, with a high collar and pauldrons shaped like falcon wings."
    * **Provide Context and Intent:** Explain the purpose of the image. The model's understanding of context will influence the final output. For example, "Create a logo for a high-end, minimalist skincare brand" will yield better results than just "Create a logo."
    * **Use Step-by-Step Instructions:** For complex scenes with many elements, break your prompt into steps. "First, create a background of a serene, misty forest at dawn. Then, in the foreground, add a moss-covered ancient stone altar. Finally, place a single, glowing sword on top of the altar."
    * **Use "Semantic Negative Prompts":** Instead of saying "no cars," describe the desired scene positively: "an empty, deserted street with no signs of traffic."
    * **Control the Camera:** Use photographic and cinematic language to control the composition. Terms like wide-angle shot, macro shot,

#### Supportet image formats
Gemini supports the following image format MIME types:

 *    PNG - image/png
 *    JPEG - image/jpeg
 *    WEBP - image/webp
 *    HEIC - image/heic
 *    HEIF - image/heif

#### Limitations and key technical information
##### File limit 
Gemini 2.5 Pro/Flash, 2.0 Flash, 1.5 Pro, and 1.5 Flash support a maximum of 3,600 image files per request.

##### Token calculation
Gemini 2.5 Flash/Pro: 258 tokens if both dimensions <= 384 pixels. Larger images are tiled into 768x768 pixel tiles, each costing 258 tokens.
A rough formula for calculating the number of tiles is as follows:
 *   Calculate the crop unit size which is roughly: floor(min(width, height) / 1.5).
 *   Divide each dimension by the crop unit size and multiply together to get the number of tiles.

For example, for an image of dimensions 960x540 would have a crop unit size of 360. Divide each dimension by 360 and the number of tile is 3 * 2 = 6.
##### Tips and best practices
When using a single image with text, place the text prompt after the image part in the `contents` array.


# Frontend 
Фронтэнд состоит из:
1. Страница авторизации. 
2. Главная страница.
3. Страницы-вкладки (слоты).
4. Страница статистики.
5. Страница настроек.
## Описание web страниц фронтэнда 

### Страница авторизации
Страница авторизации на сайт выполнена согласно образцу: 
Полный шаблон см. в файле [`frontend-examples/login-page.html`](./frontend-examples/login-page.html).

### Главная страница
Главная страница служит списком всех доступных слотов AI-обработки. Полный HTML-шаблон приведён в файле [`frontend-examples/main-page.html`](./frontend-examples/main-page.html).

* Верхняя панель (header) фиксируется при прокрутке и содержит логотип/название платформы и три иконки-действия: «Статистика», «Настройки», «Выйти».
* Основная область отображает заголовок «Слоты AI-обработки» и кнопку «Новый слот» (доступно только пользователям с правами редактирования).
* Список слотов представлен карточками/строками. Каждая строка включает:
  * кликабельное название слота, ведущее на соответствующую Страницу-вкладку;
  * краткие метаданные (последняя обработка, провайдер, состояние очереди);
  * поле с ingest-ссылкой слота и кнопку «Копировать», использующую буфер обмена браузера;
  * статусную «пилюлю» (например, «Активен», «Задержка») и быстрые действия, такие как «Сбросить статистику» или «Открыть лог».
* ingest-ссылки статичны, содержат короткое имя модели и номер слота (`/ingest/slot-00X`). Ссылки соответствуют разделу [API DSLR Remote Pro](#dslr-post) и дублируются на странице слота перед кнопкой «Сохранить».
* Внизу списка показывается пустое состояние с подсказкой, если слоты ещё не настроены.

### Страница статистики
Отображает таблицу по всем слотам и служебный блок с глобальными агрегатами. Для каждой строки слота UI использует агрегированные значения из поля `summary` ответа [`GET /api/stats/{slot_id}`](#get-apistatsslot_id):

* **Имя слота** — `summary.title` из ответа (если не передан, используется `slot_id`).
* **AI обработок (с последнего сброса)** — `summary.success` (количество успешных задач).
* **Всего ingest-запросов** — `summary.ingest_count` (включает успешные и ошибочные вызовы).
* **p95 времени ответа** — `summary.p95_response_ms` (миллисекунды по успешным задачам за выбранный диапазон).
* **Процент ошибок** — `summary.error_rate_percent` (0–100, учитывает `ingest_count`).
* **Цена последней AI обработки** — `summary.last_cost` (в валюте слота; `null`, если успешных запусков не было).
* **Суммарная стоимость** — `summary.total_cost` (накопительно с момента `summary.last_reset_at`).
* **Дата последнего сброса** — `summary.last_reset_at` (ISO8601).
* **Кнопка «Сброс статистики»** — вызывает `POST /api/slots/{slot_id}/reset_stats`.

В правом верхнем углу страницы дополнительно выводится количество глобальных обработок и суммарная стоимость за выбранный период — значения `summary.total_runs` и `summary.total_cost` из ответа [`GET /api/stats/global`](#get-apistatsglobal). Визуально рамки таблицы рисовать не нужно.

### Страница настроек
Содержит:
1. Поле для ввода пароля, который будет передаваться приложению от DSLR Remote Pro в теле запроса.
2. Элемент управления (числовое поле или слайдер) для настройки таймаута синхронного ожидания `T_sync_response` (диапазон 45–60 секунд, по умолчанию 48). Под полем выводится подсказка о том, что связанные TTL (`ingest_ttl`, `public_link_ttl`) пересчитываются автоматически после сохранения.
3. Поля для ввода API ключей от AI моделей.
4. Кнопка "Очистить мультимедиа кеш" запускает фоновую очистку временных объектов (`media_object` с истекшим TTL) и файлов, которые больше не упомянуты в `Job.result_file_path`; актуальные результаты остаются на месте, `template_media` не затрагиваются.
   * В интерфейсе рядом с кнопкой показан серый хинт: «Удаляются только устаревшие временные файлы; последний обработанный результат останется доступным».
   * После клика кнопка показывает состояние `loading` и тост «Очистка запланирована: будут удалены только устаревшие временные файлы», чтобы не обещать мгновенного удаления.
5. Кнопка "Сохранить".

### Страницы-вкладки
Каждая страница-вкладка представляет интерфейс управления конкретным слотом и работает с тем же набором полей, что и запись в таблице `Slot`. Для MVP необходимо поддержать 15 страниц-вкладок — по одной на каждый слот из глобального пула, созданного миграцией и сопоставленного фиксированной ingest-ссылке (`slot-001` … `slot-015`). Дополнительные страницы не появляются и не удаляются: как и слоты в БД, они переиспользуются при повторной настройке.
На странице-вкладке сверху отображается название AI-модели для выбранного слота и поле ввода «Название». Значение этого поля становится кликабельным именем слота на главной странице и ведёт обратно на соответствующую страницу-вкладку.
Форма на странице-вкладке собирает данные для AI-обработки: название задачи, текстовый промпт, опциональный шаблон (изображение №2) и опционально тестовое фото для локальной проверки. Все пользовательские данные, кроме тестового фото, сохраняются в слоте в базе данных. Интерфейс и внешний вид всех страниц-вкладок идентичны, отличаются только содержимым полей.
Перед кнопкой «Сохранить» отображается привязанная ingest-ссылка — та же, что создаётся миграциями и видна на главной странице для пользовательского [POST-запроса](#dslr-post).
#### Спецификация Страницы владки
Эта спецификация не обязательна, а лишь отображает примерный сценарий страницы.  Больше внимания следует уделить [Примеру оформления Страницы-вкладки](#slot-exmpl)
##### Что происходит на странице
1. Пользователь вводит Название и Промпт к ИИ.
2. Тумблерами включает загрузку:
 * второго изображения (шаблон стиля/замены лица/фона),
 * тестового фото (для локальной проверки).
3. Для шаблонного изображения (№2) — drag&drop/клик по зоне с валидацией JPG/PNG: успешная загрузка вызывает `POST /api/template-media/register`,
   сохраняет `template_media_id` и обновляет превью; кнопка «Убрать» триггерит `DELETE /api/template-media/{id}` и очищает привязку.
   Когда выбран провайдер Turbotext (или любой с `requires_public_media=true`), фронтенд не предлагает загрузку HEIC/HEIF и подсвечивает
   ошибку ещё до отправки файла, руководствуясь `MEDIA_ALLOWED_MIME`.
4. Для тестового фото и прочих временных вложений — загрузка через `POST /api/media/register`, хранение `media_object.id`, превью и очистка по TTL.
5. Скрытые поля `*_status` помечают, загружен ли файл (`present/removed`).
6. **Тест1**: если загружено тест-фото — вспышка-анимация формы и тост «успех», иначе тост-ошибка.
7. **Сохранить1**: визуальный «блик» формы; реального POST нет (submit отключён).

##### Модули и логика (верхний уровень) 

* Форма `#upload-form`
Хранит все поля. Submit заблокирован (`onsubmit="return false"`), кнопка «Сохранить1» — `type="button"`. 
* Переключатели (тумблеры) 
`toggle-second` и `toggle-first` показывают/скрывают секции загрузки, меняют только отображение. 
* Загрузка изображений (два слота)
Обработчик `bindSlot(prefix)` настраивает input + drop-зону, валидацию MIME/расширения, превью через `URL.createObjectURL`, управление `*_status`. 
* Подсказки/валидации
Серые хинты, текст ошибки под слотом, тосты (успех/ошибка сети/ошибка сервера — задел на будущее). 
* Анимация формы
Один кейфрейм `@keyframes pulseForm` (opacity 1 → 0.08 → 1, 0.4s) и один класс `-pulse`; хелпер `pulse(el)` перезапускает анимацию. Привязано к «Тест1» (только при наличии фото) и «Сохранить1». 
* Доступность
role="button", aria-label, sr-only, фокус-обводки, большие зоны клика; превью и кнопка «Убрать» доступны с клавиатуры. 
* Self-tests (консольные)
Лёгкие проверки наличия узлов/атрибутов для ранней диагностики в DevTools.

##### Технологии и инструменты
* HTML + CSS (кастомные свойства, gradients, blur)
UI-оформление, фон «дышит», стекло-эффект у формы, адаптивные размеры. 
* Vanilla JS
Тумблеры, drop-зоны, превью, тосты, хелпер анимации pulse. 
* HTMX (подключён)
Сейчас не используется для POST (оставлен на будущее); есть обработчики событий HTMX и контейнер для ответа сервера. 

##### TODO на будущее (интеграция)
Включить отправку multipart/form-data через HTMX (`hx-post="/api/save"` + `hx-target` уже готовы).
Серверная валидация размеров/типов, сохранение и возврат статуса/ID.
Доп. кнопки тестов могут дергать `/api/test` и стримить прогресс.
Если нужно описание в README-формате или краткую тех-спеку для задачи/тикета — сгенерирую.

#### Пример оформления Страницы-вкладки {id="slot-exmpl"}
В данном примере отсутствует Отображение названия AI модели и отображение ingest-ссылки, однако их нужно добавить в Страницы-вкладки.
Cтраницы-вкладки с настройками слота AI редактированием изображений должны быть оформлены по следующему примеру:
Полный пример интерфейса приведён в файле [`frontend-examples/slot-page.html`](./frontend-examples/slot-page.html).

