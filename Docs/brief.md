# Бриф PhotoChanger Platform

## Назначение платформы
PhotoChanger — серверная платформа для AI-обработки фотографий. Система принимает ingest-запросы от DSLR Remote Pro и по заранее
настроенным "слотам" маршрутизирует их к подходящему AI-провайдеру. Платформа удерживает синхронное соединение до наступления
конфигурируемого дедлайна `T_sync_response` (45–60 с) и либо возвращает результат в пределах окна ожидания, либо завершает запрос
с 504, фиксируя статус задачи. Основные ограничения и формулы TTL подробно раскрыты в [доменной модели](../spec/docs/blueprints/domain-model.md).

## Пользовательский workflow
1. Администратор авторизуется в веб-интерфейсе и попадает на главную страницу со списком слотов.
2. При выборе слота открывается страница настроек: выбираются провайдер, операция и параметры. Интерфейс подстраивается под выбранную
   операцию, запрашивая необходимые шаблоны или временные загрузки.
3. Сохранённый слот отображает ingest-ссылку с кнопкой копирования. DSLR Remote Pro использует эту ссылку для отправки `POST` с
   изображением, паролем и дополнительными полями.
4. Статус выполнения и результат обработки доступны в интерфейсе после завершения задачи. Повторный запуск выполняется тем же
   ingest-POST.

Подробные сценарии UI и взаимодействий описаны в [use-cases](../spec/docs/blueprints/use-cases.md) и [vision](../spec/docs/blueprints/vision.md).

## Цель платформы и общий процесс
Платформа синхронно обрабатывает ingest-запросы и управляет асинхронной очередью. Получив POST, API валидирует входные данные,
создаёт `Job`, рассчитывает дедлайны (`expires_at`, `T_ingest_ttl`, `T_public_link_ttl`) и ожидает ответ воркера до наступления `T_sync_response`.
Воркер подбирает задачу из очереди (`SELECT … FOR UPDATE SKIP LOCKED`), вызывает провайдера и обновляет запись `Job`. При успехе
результат сериализуется в `Job.result_*` и возвращается клиенту; при таймауте или ошибке фиксируется `failure_reason`, а временные
данные очищаются. Поведение очереди и дедлайнов подробно раскрыто в разделе "Контур дедлайнов" доменной модели.

Если провайдер Turbotext не возвращает результат до наступления `T_sync_response`, Ingest API отвечает 504, но задача остаётся в очереди.
`Job.provider_job_reference` хранит `queueid`, по которому воркер продолжает polling `do=get_result` до дедлайна `expires_at`.
Полученный позднее результат сохраняется в `Job.result_*`, а UI отображает обновлённый статус без участия webhook.

## Провайдеры и операции
### Gemini
- Поддерживает генерацию, редактирование, слияние изображений на модели `gemini-2.5-flash-image` через `models.generateContent`.
- Работает с Files API и ограничивает форматы `image/png`, `image/jpeg`, `image/webp`, `image/heic`, `image/heif`.
- Ограничения по размеру (≤ 2 ГБ) и квоты (500 rps, 2 000 rpd) учитываются при валидации и планировании запросов.

### Turbotext
- Выполняет style-transfer, image-to-image и deepfake-сценарии через `api_ai` с поддержкой очереди и polling.
- Требует временных публичных ссылок (`media_object`) и работает с MIME `image/jpeg`, `image/png`, `image/webp`.
- Возвращает `queueid`, который сохраняется в `Job.provider_job_reference` и используется воркером для повторного polling до финализации задачи.

Детализированные настройки входов/выходов и маппинг полей находятся в [конфигурации провайдеров](../spec/docs/blueprints/domain-model.md#модели-данных-postgresql--alembic)
и соответствующих разделах [openapi-контракта](../spec/contracts/openapi.yaml).

## Медиа-хранилища и TTL
Платформа использует два типа хранилищ:
- **Временное публичное хранилище** (`media_object`) выдаёт ссылки, живущие `T_public_link_ttl = clamp(T_sync_response, 45, 60)` секунд. Продление не
  предусмотрено: по истечении срока задача получает `failure_reason = 'timeout'`, данные удаляются, а для повторного использования файл регистрируется
  заново. Механизм описан в [constraints-risks](../spec/docs/blueprints/constraints-risks.md) и [test-plan](../spec/docs/blueprints/test-plan.md).
- **Постоянные шаблоны** (`template_media`) хранят эталонные изображения для слотов. Они управляются вручную и не очищаются автоматически.

Итоговые результаты записываются в `Job.result_*`, а base64-строка хранится только на время синхронного ожидания (очищается после отдачи HTTP 200/504).
Временные загрузки и шаблоны связываются со слотами через конфигурацию `settings_json`; детально — в [domain-model](../spec/docs/blueprints/domain-model.md).

## Управление настройками и секретами
Глобальные параметры (`T_sync_response`, TTLы медиа, признак наличия DSLR-пароля и ключей провайдеров) управляются через страницу настроек.
API позволяет читать агрегированное состояние (`GET /api/settings`) и обновлять значения (`PUT /api/settings`). Секреты хранятся в `app_settings`
и `provider_secret` с шифрованием и не возвращаются клиенту в явном виде. Кнопка очистки медиа кеша вызывает асинхронную задачу `POST /api/media/cache/purge`.
Контракты и форматы ответов определены в [OpenAPI](../spec/contracts/openapi.yaml); требования к безопасности изложены в [nfr](../spec/docs/blueprints/nfr.md).

## Архитектурные принципы
**1. Архитектура проекта ориентирована на безопасность изменений кода** при генерации кода LLM моделью: тонкие фасады + pure domain + contract-first + Spec Driven Dev.

**2. Архитектура проекта должна обладать Низкой связанностью (low coupling):**
 * Каждый модуль/фасад имеет отдельную ответственность.
 * Сервисы и домен не знают про инфраструктуру напрямую — используют фасады и интерфейсы.
 * Любой слой зависит только от более внутреннего слоя.

**3. Архитектура проекта должна обладать Высокой когезией (high cohesion):**
 * Каждый класс или модуль отвечает за один аспект.
 * DTO и типы фиксируют контракты между слоями, уменьшая «размазанность» логики.

## Архитектурный обзор
- **Ingest API** — валидирует запросы, рассчитывает дедлайны, ожидает синхронный ответ и завершает соединение строго по `T_sync_response`.
- **Очередь на PostgreSQL** — таблица `job` выступает очередью с `SELECT … FOR UPDATE SKIP LOCKED`, обеспечивая back-pressure и контроль параллелизма.
- **Воркеры** — исполняют операции провайдера, отслеживают `expires_at`, выполняют polling очередей провайдеров и гарантируют очистку временных данных.
- **UI и админ-панель** — управляют слотами, шаблонами и глобальными настройками, опираясь на статическую конфигурацию провайдеров (`configs/providers.json`) и получают статусы Job через API polling без webhook.
- **Мониторинг и логирование** — фиксируют статусы ingest, таймауты, ретраи, операции очистки и цикл polling (частота запросов `do=get_result`, задержки, долю задач с просроченным `queueid`) в `ProcessingLog` и связанных метриках.

Диаграммы взаимодействий и ответственности компонентов приведены в [context](../spec/docs/blueprints/context.md) и [use-cases](../spec/docs/blueprints/use-cases.md).

## Ключевые сущности
- `Slot` — статический пул из 15 ingest-слотов (`slot-001` … `slot-015`), конфигурируемых администраторами.
- `Job` — запись очереди обработки: хранит статус, дедлайн (`expires_at`), ссылки на результат и `provider_job_reference`.
- `MediaObject` — временная публичная ссылка с жёстким TTL.
- `TemplateMedia` — долговечные шаблонные файлы.
- `ProcessingLog` — аудит ingest-запросов, включая статус, время ответа и ошибки.

Полная структура полей и инварианты описаны в [domain-model](../spec/docs/blueprints/domain-model.md) и согласованы с [openapi.yaml](../spec/contracts/openapi.yaml).

## Работа с провайдерами
- Воркер регистрирует временные файлы при необходимости (`POST /api/media/register`), передаёт публичные URL провайдеру и отслеживает загрузку до истечения TTL.
- Для асинхронных сценариев Turbotext сохраняется `queueid`; воркер опрашивает `do=get_result` с учётом дедлайнов. Если результат приходит после дедлайна,
  он игнорируется, задача остаётся в `failure_reason = 'timeout'`.
- Gemini получает бинарные данные напрямую или через Files API; обработанные изображения скачиваются и сохраняются в `Job.result_*`.

Специфика интеграций и лимиты операций перечислены в [providers configuration](../spec/docs/blueprints/domain-model.md#провайдеры-и-операции) и [nfr](../spec/docs/blueprints/nfr.md).

## Ссылки на спецификации
- [spec/contracts/openapi.yaml](../spec/contracts/openapi.yaml) — полный HTTP-контракт: эндпоинты ingest, слотов, настроек, медиа и статусов.
- [spec/docs/blueprints/context.md](../spec/docs/blueprints/context.md) — акторы, границы системы и диаграммы последовательностей.
- [spec/docs/blueprints/use-cases.md](../spec/docs/blueprints/use-cases.md) — сценарии UI и ingest, включая таймауты и polling.
- [spec/docs/blueprints/domain-model.md](../spec/docs/blueprints/domain-model.md) — сущности БД, TTL и связи.
- [spec/docs/blueprints/nfr.md](../spec/docs/blueprints/nfr.md) — нефункциональные требования, ретраи, безопасность и мониторинг.
- [spec/docs/blueprints/test-plan.md](../spec/docs/blueprints/test-plan.md) — стратегия тестирования и ключевые проверки TTL.
- [spec/docs/blueprints/vision.md](../spec/docs/blueprints/vision.md) — целевая ценность продукта и метрики успеха.
- [spec/docs/blueprints/constraints-risks.md](../spec/docs/blueprints/constraints-risks.md) — ограничения и риски асинхронной обработки.

Этот бриф остаётся источником повествовательного контекста и дополняет формальные спецификации, определяющие контракты и реализацию.
