# Анализ Issue: JobCompletionNotifier для Ingest API

## Контекст
- **Issue:** Ingest API ожидает финализации Job, но отсутствует механизм, который пробуждает ожидающий HTTP-поток; остаётся только активный polling по БД. Предлагалось добавить явный JobCompletionNotifier (например, Postgres LISTEN/NOTIFY или внутрипроцессный брокер).
- **Задача:** оценить, достаточно ли для наших сценариев периодического polling (≈1 раз в секунду) без усложнения архитектуры.

## Что говорят спецификации
- UC2 фиксирует, что Ingest API после постановки Job в очередь ждёт результат внутри `T_sync_response`, а воркер по завершении обновляет запись `Job`, включая `is_finalized` и метаданные результата.【F:spec/docs/blueprints/use-cases.md†L36-L61】
- UC3 и диаграмма состояний подтверждают: при наступлении таймаута API самостоятельно завершает ожидание с 504, а задача финализируется без дополнительных каналов уведомления.【F:spec/docs/blueprints/use-cases.md†L64-L85】
- Описание доменной модели подчёркивает, что факт финализации и статус `Job` хранится в БД (`is_finalized`, `failure_reason`, `finalized_at`), а `provider_job_reference` служит исключительно для polling со стороны воркера.【F:spec/docs/blueprints/domain-model.md†L16-L25】【F:spec/docs/blueprints/domain-model.md†L53-L86】
- OpenAPI контракт `POST /ingest/{slotId}` детально описывает дедлайн ожидания (`T_sync_response`) и последствия таймаута, но не предъявляет требований к отдельному каналу уведомлений; конечное состояние определяется полями `Job` и ответом API.【F:spec/contracts/openapi.yaml†L710-L758】

## Оценка подходов
- **Периодический polling БД (ингест → Job):** при текущих вводных (редкие запросы ≈1/мин, минимальный параллелизм) цикл чтения `Job` раз в секунду даёт ≤60 обращений к БД на запрос, что существенно ниже типичных лимитов Postgres. Такой подход естественно вписывается в уже описанную модель данных и не требует новой инфраструктуры уведомлений.
- **JobCompletionNotifier (LISTEN/NOTIFY, брокер):** усложняет архитектуру (дополнительные соединения, обработка перезапусков, тестирование гоночных условий), но не решает спецификационно значимых проблем: `Job` всё равно должен быть финализирован через обновление записи, а HTTP-поток обязан закрыться по `T_sync_response` даже при сбое нотификатора.
- **Риски polling:** единственный риск — избыточное время до обнаружения финализации. При шаге 1 с максимальная задержка доставки ответа ≤1 с, что укладывается в окно `T_sync_response` (45–60 с) и не влияет на SLA. Даже в случае таймаута API по спецификации завершит запрос самостоятельно без необходимости внешнего сигнала.

## Вывод
Спецификации не требуют отдельного JobCompletionNotifier: достаточным источником истины остаётся запись `Job`. С учётом низкой нагрузки и ограниченного параллелизма разумно реализовать ожидание результата как цикл polling с шагом ~1 с до наступления `is_finalized` или дедлайна `T_sync_response`. Это упрощает систему и не противоречит описанным контрактам и сценариям.
