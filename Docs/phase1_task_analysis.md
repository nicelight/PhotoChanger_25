# Phase 1 Task Analysis — Memory API & Infrastructure Scaffolding

Документ описывает потенциальные риски и подводные камни реализации задач Фазы 1 из `.memory/TASKS.md`, а также дополнительные разбиения для сложных сабтасков.

## MB-1.1 — Inventory existing stubs
### MB-1.1.1 — Audit `src/app` для memory-контроллеров и репозиториев
**Подводные камни:**
- Возможны расхождения между актуальной OpenAPI-спецификацией и уже сгенерированными контроллерами; потребуется сверка контрактов до начала аудита.
- Код может быть распределён по нескольким модулям (`src/app`, `src/modules`, `src/shared`), что усложнит полноту аудита без картирования зависимостей.
- Отсутствие тестов или устаревшие стаб-версии могут привести к неверным выводам об актуальности заглушек.
**Декомпозиция:**
1. Собрать перечень существующих контроллеров/репозиториев через статический анализ и инспекцию дерева.
2. Сопоставить найденные элементы с эндпоинтами и сущностями из OpenAPI/JSON Schema.
3. Зафиксировать несоответствия (лишние/отсутствующие/устаревшие стаб-методы) с указанием файлов.

### MB-1.1.2 — Identify missing scaffolds for memory endpoints
**Подводные камни:**
- Неочевидные зависимости (middleware, DTO) могут быть пропущены без предварительной схемы архитектуры.
- Отсутствие единого источника правды по маршрутам (например, роутер конфигурируется динамически).
- Возможность дублирования работы, если параллельно генерируются новые стаб-контроллеры.
**Декомпозиция:**
1. Построить карту текущих маршрутов (router map) и сравнить её с требуемыми эндпоинтами.
2. Проверить наличие соответствующих DTO/моделей запросов/ответов.
3. Сформировать список отсутствующих стабов с оценкой влияния и зависимостей.

### MB-1.1.3 — Document gaps с ссылками на контракты и модули
**Подводные камни:**
- Трудно поддерживать актуальность без шаблона отчёта; возможна потеря связи между контрактами и кодом.
- Требуется чёткая трассировка до владельцев модулей, иначе задачи останутся без ответственных.
**Декомпозиция:**
1. Подготовить шаблон отчёта (таблица или md-файл) с колонками «Контракт», «Модуль», «Статус», «Владелец».
2. Заполнить отчёт результатами из MB-1.1.1 и MB-1.1.2.
3. Разместить отчёт в Docs или .memory и согласовать с ответственными командами.

## MB-1.2 — Generate infrastructure stubs
### MB-1.2.1 — Prepare prompts для контроллеров и моделей
**Подводные камни:**
- Неполные подсказки могут привести к невалидному коду (несогласованные типы, ошибки валидации).
- Требуется учесть доменные инварианты (TTL, лимиты размеров медиа) внутри подсказок.
- Риск дрейфа между версиями контрактов и генерируемыми шаблонами.
**Декомпозиция:**
1. Собрать инварианты и требования из контрактов и NFR.
2. Сформировать структуру prompt-шаблонов (контекст, входы, ожидаемый вывод).
3. Провалидировать подсказки через пробные генерации и ревью.

### MB-1.2.2 — Prepare prompts для сервисов, адаптеров, воркеров
**Подводные камни:**
- Высокая связанность сервисов требует описания зависимостей (репозитории, очереди, провайдеры).
- Необходимо учитывать сценарии ошибок/ретраев, иначе заглушки будут неполными.
- Возможна необходимость нескольких вариантов подсказок под разные генераторы LLM.
**Декомпозиция:**
1. Определить перечень сервисов/адаптеров/воркеров и их ответственность.
2. Задокументировать входы/выходы и требования по обработке ошибок.
3. Подготовить prompt-пакеты (основной + error-handling) и проверить на пилотной генерации.

### MB-1.2.3 — Ensure placeholder implementations для storage drivers и DI
**Подводные камни:**
- Регистрация в DI-контейнере может зависеть от окружений (dev/prod); важно учесть конфигурации.
- Нужно предусмотреть интерфейсы и моки для будущих тестов.
- Неполная заглушка storage driver может заблокировать интеграционные тесты в следующих фазах.
**Декомпозиция:**
1. Определить перечень storage drivers (media, метаданные, очереди) и требуемые интерфейсы.
2. Создать минимальные реализации/заглушки с логированием и валидацией входных данных.
3. Зарегистрировать заглушки в DI и задокументировать параметры конфигурации.

## MB-1.3 — Automate static validation
### MB-1.3.1 — Configure linting и type checking
**Подводные камни:**
- Разные языки/фреймворки в монорепозитории могут требовать отдельной конфигурации инструментов.
- Конфликты версий линтеров и форматтеров с текущими настройками CI.
- Неочевидные исключения (генерируемый код) могут вызвать «ложные» ошибки без корректной фильтрации.
**Декомпозиция:**
1. Провести инвентаризацию технологий (Node, Python, etc.) и существующих конфигов.
2. Определить список линтеров/тайпчекеров и добавить недостающие зависимости.
3. Настроить скрипты запуска (package.json/Makefile) и обновить документацию по использованию.

### MB-1.3.2 — Add rollback scripts или git hooks
**Подводные камни:**
- Hook'и могут мешать разработчикам (дополнительное время запуска); нужен баланс между безопасностью и скоростью.
- Скрипты должны корректно работать на разных ОС/шеллах.
- Риск случайного удаления нужных изменений при агрессивном rollback.
**Декомпозиция:**
1. Определить стратегию отката (pre-commit hook, npm script, standalone CLI).
2. Реализовать и протестировать hook/скрипт на типичных сценариях генерации.
3. Задокументировать процесс отката и способы отключения при необходимости.

### MB-1.3.3 — Establish success criteria для автоматизации
**Подводные камни:**
- Отсутствие измеримых метрик затруднит принятие решения о готовности.
- Нужно согласовать критерии со стейкхолдерами (инфра, разработка, QA).
- Возможно потребуется обновить CI/CD, чтобы собирать метрики автоматически.
**Декомпозиция:**
1. Определить ключевые метрики (время генерации, % успешных проверок, покрытие).
2. Описать пороги успешности и SLA для pipeline.
3. Зафиксировать критерии в документации и встроить проверку в CI.

## MB-1.4 — Stub coverage tracking
### MB-1.4.1 — Maintain index of generated stubs
**Подводные камни:**
- Нужна единая схема идентификаторов (эндпоинт ↔ stub), иначе отслеживание сложное.
- Требуется автоматизация обновления индекса, иначе быстро устареет.
- Возможны расхождения между документацией и реальным кодом при ручном обновлении.
**Декомпозиция:**
1. Выбрать формат индекса (YAML/JSON/Markdown) и расположение в репозитории.
2. Составить первичную версию индекса, связав стабы с контрактами и модулями.
3. Настроить процесс обновления (скрипт или чек-лист при генерации новых стабов).

### MB-1.4.2 — Verify coverage по маршрутам и сущностям
**Подводные камни:**
- Отсутствие инструментов статического анализа роутов затруднит проверку.
- Разные версии сущностей (DTO vs domain model) могут запутать проверку соответствия.
- Необходимо учесть внутренние сервисы (очереди, воркеры) помимо HTTP API.
**Декомпозиция:**
1. Сравнить индекс из MB-1.4.1 с OpenAPI и доменной моделью.
2. Подготовить чек-лист/скрипт для автоматизированной верификации соответствия.
3. Зафиксировать uncovered элементы и их влияние.

### MB-1.4.3 — Report uncovered routes/entities
**Подводные камни:**
- Без ответственных и сроков отчёты могут игнорироваться.
- Нужно согласовать формат (dashboard, md, ticket) и канал коммуникации.
- Риск дублирования задач в разных трекинг-системах.
**Декомпозиция:**
1. Подготовить шаблон отчёта с полями «Элемент», «Риск», «Владелец», «ETA».
2. Автоматизировать сбор отчёта (скрипт или экспорт из индекса).
3. Интегрировать отчёт в backlog-процесс (создание задач, уведомления).
