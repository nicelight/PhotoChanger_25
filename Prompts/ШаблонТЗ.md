# PhotoChanger — Техническое заание (подробное, MD)
*Данное ТЗ составлено нейронной сетью GPT5 https://chatgpt.com/c/68c8d7b4-fbdc-8323-ab5b-c86dbc8111c8*

## 1. Краткое описание

PhotoChanger — лёгкий FastAPI‑сервер для AI‑обработки фотографий, интегрируемый с DSLR Remote Pro.
Рабочий сценарий: DSLR Remote Pro отправляет `multipart/form-data` (JPEG) на URL (copy‑paste ссылка из веб‑интерфейса). Сервер находит соответствующий слот, применяет преднастройки (тип обработки, промпт, опциональный эталон), ждёт ответ AI‑модели до 50 секунд и возвращает обработанное изображение (JPEG/PNG) в теле HTTP‑ответа. Входной файл удаляется после ответа. Веб‑интерфейс для управления слотами доступен по Basic Auth.

---

## 2. Цели MVP

* Надёжный, простой и минималистичный код.
* Синхронный поток: DSLR ждёт ответа до 50 сек.
* UI: 3 вкладки (Turbotext, Deepseek, NanoBanana), в каждой — до 20 слотов, слоты редактируемы.
* Каждый слот хранит: тип обработки, промпт, эталонное изображение (JPEG), copy‑paste URL.
* Исходные и результатные изображения удаляются/очищаются после использования (в соответствии с политикой).
* Basic Auth для управления UI.
* Dockerized (Dockerfile + docker‑compose).

---

## 3. Не в рамках MVP

* Распределённый GPU‑кластер и автоматическое масштабирование (опционально, позднее).
* Экспорт/импорт преднастроек (не требуется).
* Статистика доступна только через защищённую кнопку (пароль в UI не показываем; см. раздел Security).
* Поддержка сложных workflow и многопользовательской роли (по требованию в будущем).

---

## 4. Основные допущения и параметры (по умолчанию)

* Поддерживаемые форматы входа: JPEG (DSLR присылает JPEG). Ответ допускает JPEG или PNG.
* Таймаут ожидания ответа от AI: **50 секунд** (жёстко).
* Максимальный размер входного файла (по умолчанию): **50 MB**. *TODO: подтвердить/изменить.*
* Количество вкладок: **3** (фиксированные).
* Слотов на вкладку: **20** (фиксированные).
* Эталонное изображение: JPEG любого размера (сервер должен принимать и хранить).
* Очереди обработки: **не нужны**; опционально — простая очередь в одном процессе (см. раздел Optional).

---

## 5. Архитектура (высокоуровнево)

* **FastAPI** приложение (ASGI) — основной HTTP API и UI‑страницы.
* **AI Adapter(s)** — модуль(и) с абстракцией для вызова конкретных моделей (Turbotext, Deepseek, NanoBanana). Каждый adapter выполняет sync вызов модели и возвращает байты результата.
* **Хранилище**: локальная файловая система для шаблонов и временных файлов. *TODO: уточнить путь (`/srv/photochanger` или другое).*
* **DB** (легковесно): SQLite для хранения слотов и метаданных. Структура таблиц описана ниже.
* **Auth**: Basic Auth для UI (логин/пароль в конфиге / env). *TODO: задать учётку админа.*
* **Docker**: контейнеризация, docker‑compose для локального запуска.

---

## 6. API — детальная спецификация

### 6.1. POST `/process` — основной endpoint (DSLR → сервер)

* **Описание**: Принимает `multipart/form-data` с полем `file` (JPEG). DSLR будет совершать POST на URL, который соответствует конкретному слоту (см. Slot URL mapping).
* **Request (multipart/form-data)**:

  * `file` — файл (JPEG), required.
  * (опционально) `filename` — исходное имя файла.
  * (опционально) дополнительные поля (игнорируются сервером).
* **Запуск обработки**:

  * Сервер определяет слот по URL запроса (например, path `/in/<slot_uuid>` — подробнее в разделе Slot URL).
  * Сервер читает настройки слота (тип обработки, промпт, путь к эталону).
  * Сервер вызывает соответствующий AI Adapter и ждёт ответа до 50 сек.
* **Responses**:

  * `200 OK` — `Content-Type: image/jpeg` или `image/png`; тело — байты изображения.
  * `408 Request Timeout` — если обработка заняла >50 сек. Тело: JSON `{ "error": "timeout" }` (для DSLR тело может игнорировать).
  * `400 Bad Request` — нет файла / неверный формат. Body: JSON `{ "error": "..." }`.
  * `413 Payload Too Large` — файл превышает лимит.
  * `415 Unsupported Media Type` — не image/jpeg.
  * `500 Internal Server Error` — при внутренней ошибке.
* **Примечание**: DSLR ожидает бинарную картинку — при успешной обработке не возвращаем JSON.

**Пример curl (тестовая отправка):**

```bash
curl -v -F "file=@input.jpg;type=image/jpeg" https://example.com/in/<slot_uuid> -o out.jpg
```

---

### 6.2. UI & Admin API

> UI защищён Basic Auth (username/password).

#### GET `/` — админ UI (HTML)

* Показывает 3 вкладки, каждая с 20 слотов, кнопки редактирования, загрузка эталона, генерация/копирование slot URL.

#### GET `/api/slots` — список слотов (JSON)

* Возвращает все слоты с их полями.

#### GET `/api/slots/{slot_uuid}` — подробности слота

#### POST `/api/slots/{slot_uuid}` — обновить слот

* Поля: `type`, `prompt`, `template_file` (upload), `enabled` и т.д.

#### POST `/api/templates` — загрузить эталон (если нужен общий менеджмент)

* Возвращает `template_id`.

#### GET `/api/stat` — статистика (защищено admin)

* Возвращает число обработанных фото на модель, последние ошибки и т.п. Доступ к этому endpoint — по Basic Auth. *TODO: добавить пароль/ключ для экспорта ссылок?*

---

## 7. Slot URL mapping (как DSLR попадает в нужный слот)

* Каждый слот имеет уникальный `slot_uuid` (UUID v4).
* UI генерирует для слота URL вида:

  * `https://<host>/in/<slot_uuid>`
* DSLR вставляет этот URL в свою настройку «URL for upload».
* Сервер при запросе на `/in/<slot_uuid>` ищет слот в БД и применяет настройки.

*TODO: подтвердить формат URL (path или query param) и домен/порт, которые будут использоваться.*

---

## 8. Данные / Схема БД (SQLite, пример)

### Таблица `slots`

* `id` INTEGER PK
* `uuid` TEXT UNIQUE (slot\_uuid)
* `model_name` TEXT (Turbotext|Deepseek|NanoBanana)
* `index` INTEGER (1..20)
* `type` TEXT (`face_swap`|`background_replace`|`prompt_generation`)
* `prompt` TEXT
* `template_path` TEXT (путь к файлу эталона) — NULL если нет
* `slot_url` TEXT (полный URL или path)
* `enabled` BOOLEAN
* `created_at` TIMESTAMP
* `updated_at` TIMESTAMP

### Таблица `stats` (опционально)

* `id`, `model_name`, `count_success`, `count_fail`, `last_processed_at`

### Таблица `templates` (опционально)

* `id`, `filename`, `path`, `uploaded_at`

---

## 9. Файловая структура на диске и именование

* Root для данных: `DATA_ROOT`. *TODO: задать абсолютный путь (например `/srv/photochanger`).*
* Поддиректории:

  * `templates/` — эталонные изображения (файлы, сохранять постоянно)
  * `tmp/incoming/<uuid>/` — временная папка для входного файла (удаляется после обработки)
  * `tmp/garbage/` — перемещать файлы по таймауту/ошибке
* Именование файлов:

  * `{timestamp}_{uuid}_{role}.{ext}`, где `role` ∈ {`content`, `template`, `result`}
  * Формат timestamp: `YYYYMMDDTHHMMSS` (UTC)
* JSON метаданные для каждой обработки (в tmp): `{id, slot_uuid, template, model, started_at, finished_at, status, error}`

---

## 10. AI Adapters — интерфейс

Каждый adapter — простой sync‑функциональный интерфейс:

```python
def process_with_<adapter>(input_bytes: bytes, slot_meta: dict, timeout: int = 50) -> bytes:
    """
    - input_bytes: байты JPEG
    - slot_meta: { 'type':..., 'prompt':..., 'template_path':..., 'model_name':... }
    - timeout: seconds to wait for model
    Returns: байты обработанного изображения (JPEG/PNG)
    Raises: AdapterError on failure or timeout
    """
```

*TODO: для каждой модели указать реальные API/cli/локальные вызовы (если внешняя служба) — endpoint, auth, формат запросов.*

---

## 11. Поведение по таймауту и ошибкам

* Если AI Adapter не вернул результат в пределах 50 сек → abort, вернуть `408 Request Timeout` клиенту.
* В случае таймаута и ошибок: переместить входной файл в `tmp/garbage/` и записать запись об ошибке в лог и в `tmp/<meta>.json`.
* Любые внутренние ошибки → `500 Internal Server Error`.
* При `400/413/415` — вернуть JSON с полем `error`.

---

## 12. Безопасность

* **Basic Auth** для UI и всех `/api/*` эндпоинтов админки. *TODO: задать логин/пароль или ссылаться на env переменные.*
* Для основного `/in/<slot_uuid>` endpoint — публичный (DSLR отправляет), но:

  * Проверять размер и тип файла,
  * Лимитировать одновременные соединения (rate limiting) — *TODO: указать лимит, если нужно*.
* Логи: не записывать raw image bytes в логи.
* HTTPS: TLS обязателен в продакшне (через reverse proxy: Nginx/Traefik).

---

## 13. Логирование и мониторинг

* Логи в stdout (структурированный JSON желательно). Полезные события:

  * `incoming_request` (slot\_uuid, client\_ip, file\_size)
  * `processing_started` (slot\_uuid, model)
  * `processing_finished` (slot\_uuid, duration\_ms, status)
  * `processing_failed` (error)
* Метрики (optonal): `/metrics` Prometheus (кол‑во запросов, латентность, success/fail per model). *TODO: нужно ли включать Prometheus?*

---

## 14. UI — детальное описание

* **Аутентификация**: Basic Auth.
* **Главная страница**:

  * Три вкладки: Turbotext | Deepseek | NanoBanana.
  * Вкладка содержит таблицу/сетку из 20 слотов (номер слота 1..20).
  * Для каждого слота:

    * Поле `enabled` (on/off).
    * Select `type` (face\_swap|background\_replace|prompt\_generation).
    * Textarea `prompt`.
    * Кнопка `Upload template` (отдельное поле — сохраняет `template_path`).
    * Поле `slot_url` (readonly) + кнопка `Copy`.
    * Кнопка `Save` (обновить слот).
  * Минимальная preview картинка (thumbnail) для шаблона (если загружен).
* **Кнопка статистики**:

  * Ввод пароля (не показывать в cleartext) → доступ к `/api/stat`.
  * *TODO: как именно предоставлять пароль/доступ — задать политику.*

UI должен быть минимальным, статическим HTML/vanilla JS или лёгкой SPA (React/Vue) — предпочтение: минимальный server‑rendered HTML с небольшим JS (чтобы нейросеть писала простой код).

---

## 15. Тестирование / acceptance tests

* Unit tests для:

  * Валидации входа (тип, размер).
  * Правильное маппирование slot\_uuid → слот.
  * Правильное удаление временных файлов.
* Integration tests:

  * `curl` отправка файла на `/in/<slot_uuid>` и получение `200` + валидное изображение (binary).
  * Таймаут‑симуляция: adapter искусственно задерживает >50 сек → получаем `408`.
* Acceptance criteria (обязательные):

  1. DSLR request `POST /in/<slot_uuid>` с JPEG → возвращает `200` с изображением, если AI ответил в <= 50s.
  2. Если AI >50s → `408` и исходный файл перемещён в `tmp/garbage`.
  3. UI позволяет редактировать слоты, загружать шаблон, копировать slot URL.
  4. Временные входные файлы удаляются/перемещаются после ответа.

---

## 16. Dev / Deployment

* **Dockerfile**: собирает приложение, всё в одном образе.
* **docker-compose.yml**: для локальной разработки (FastAPI + SQLite + optional Redis). *TODO: решить, нужен ли Redis.*
* Запуск в prod: `gunicorn -k uvicorn.workers.UvicornWorker main:app -w <NWORKERS>` за Nginx. *TODO: задать NWORKERS / ресурсы.*
* Конфиги через env vars:

  * `DATA_ROOT`, `ADMIN_USER`, `ADMIN_PASS`, `MAX_FILE_SIZE`, `AI_TIMEOUT`, `DATABASE_URL`, `LOG_LEVEL`.

---

## 17. Проектная структура (рекомендуемая, простая)

```
photochanger/
├─ app/
│  ├─ main.py               # FastAPI app + routes
│  ├─ config.py             #读取 env vars
│  ├─ models.py             # Pydantic схемы
│  ├─ db.py                 # sqlite helper, simple ORM
│  ├─ ai_adapters/
│  │   ├─ __init__.py
│  │   ├─ turbotext.py
│  │   ├─ deepseek.py
│  │   └─ nanobanana.py
│  ├─ storage.py            # file save/remove helpers
│  ├─ auth.py               # Basic Auth
│  └─ templates/            # static admin templates (HTML)
├─ tests/
├─ Dockerfile
├─ docker-compose.yml
├─ README.md
└─ requirements.txt
```

Код должен быть простой, модульный, маленькие функции и минимум абстракций — чтобы нейросеть могла править и дописывать.

---

## 18. Кодстайл и требования к реализации (для нейросети)

* Язык: **Python 3.10+**.
* Фреймворк: **FastAPI**.
* Минимум внешних зависимостей: `fastapi`, `uvicorn`, `python-multipart`, `pillow` (PIL) для валидации изображений, `pydantic`. *TODO: подтвердить дополнительные зависимости (requests, aiohttp, sqlite lib).*
* Чёткие, документированные функции. Простые логические блоки (не более \~50 строк на функцию).
* Обработчик `/in/<slot_uuid>` — простой, синхронный поток: save temp → call adapter → return streaming response → schedule/remove temp.

---

## 19. Acceptance checklist (что должно быть готово для сдачи)

* [ ] FastAPI app с эндпоинтом `/in/<slot_uuid>` корректно принимает JPEG и возвращает изображение.
* [ ] UI с 3 вкладками и 20 слотов в каждой, редактируемыми слотами и кнопкой копирования slot URL.
* [ ] Файловая политика: temp сохранение, удаление/garbage при таймауте.
* [ ] Basic Auth защищает UI/API.
* [ ] Dockerfile + docker-compose + README с инструкцией запуска.
* [ ] Unit + integration тесты, curl примеры.
* [ ] Логи: базовый формат и запись успешных/ошибочных событий.

---

## 20. TODO (поля, которые нужно заполнить вами)

1. **MAX\_FILE\_SIZE** (MB). По умолчанию 50 MB, подтвердите или укажите новый предел.
2. **DATA\_ROOT** (абсолютный путь на диске для хранения): например `/srv/photochanger`.
3. **Админ credentials**: `ADMIN_USER`, `ADMIN_PASS` (или схема использования secret manager).
4. **Slot URL формат и домен**: полный URL, который будет даваться DSLR (domain, port, https?).
5. **Точные интеграционные детали AI моделей**: какие API/CLI у Turbotext/Deepseek/NanoBanana — endpoint, auth, формат запроса/ответа. (Adapter нужен для каждой).
6. **Количество UVicorn workers / ресурсы в production** (NWORKERS).
7. **Нужен ли Redis/сеть или очередь для будущего** (если да — указать).
8. **Нужна ли Prometheus метрика `/metrics`**.
9. **Политика хранения шаблонов**: вечное хранение или retention X дней.
10. **Политика доступа к статистике/паролю** — как именно защищается кнопка статистики.
11. **Лимит одновременных подключений / rate limit** (если необходим).
12. **Включать ли HTTPS в контейнере или через reverse proxy**.

---

## 21. Примеры (curl)

* Отправка файла на слот:

```bash
curl -v -F "file=@input.jpg;type=image/jpeg" https://example.com/in/3f9a1b-uuid -o out.jpg
```

* Обновление слота (пример):

```bash
curl -u admin:pass -X POST "https://example.com/api/slots/3f9a1b-uuid" \
  -F "type=face_swap" \
  -F "prompt=replace face with ... " \
  -F "template=@template.j
```
