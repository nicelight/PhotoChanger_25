# agents.md — рабочая инструкция для Codex‑агента

> Этот файл описывает, **как автономно вести разработку проекта по брифу** (`/Docs/brief.md`) с помощью Codex‑агента: порядок действий, запретные зоны, чек‑листы качества, готовые промпты, команды и Definition of Done. Агент должен считать `brief.md` **единственным источником истины** и синхронизировать с ним все артефакты.

---

## 0) Главные правила

1. **Источник истины:** всегда начинать с чтения `/Docs/brief.md`. Любые расхождения решаются в пользу брифа. Если бриф обновился — выполнить цикл *Re‑Sync* (см. §9).
2. **SDD (Spec Driven Development):** прежде чем писать код, **оформляй и согласовывай спецификации**. Любые контроллеры/адаптеры/структуры данных возникают только из спецификаций. Любая реализация без спецификации запрещена.
3. **Contract‑first:** сначала спецификации (OpenAPI/JSON Schema), затем реализация. Любые контроллеры/хендлеры — только после фиксации контрактов (§2).
4. **Тонкий фасад:** внешнее API минимально. Внутри — адаптеры провайдеров AI, очередь заданий, хранилище результатов, UI слотов. Плагинообразность и низкая связанность.
5. **Безопасные изменения:** каждую правку проводить через короткий MR/PR‑пакет: *spec → stubs → tests → impl*. Отказ от «магических» скрытых побочек.
6. **Непрерывная проверка:** линтеры, mypy/pyright (если применимо), unit + контракт‑тесты, e2e моками провайдеров. CI локально (скрипт) + отчёты.
7. **Логи/метрики:** покрыть входящие запросы, время очереди, вызовы провайдеров, долю таймаутов 504, ретраи.
8. **Данные пользователей:** временное хранение, автоочистка, запрет логировать персональные фото и токены.

---

## 0.a) SDD‑мандат и артефакты

**Цель:** всё развитие ведётся через спецификации. Артефакты SDD:

* `/contracts/openapi.yaml` — HTTP‑контракт внешнего API.
* `/contracts/schemas/*.json` — JSON Schema доменных сущностей.
* `/contracts/providers/*.md` — операции/лимиты провайдеров.
* `/adr/*` — решения и компромиссы архитектуры со ссылкой на бриф.
* `/tests/contracts/*` — проверка соответствия коду и контрактам.

**Gates (обязательные ворота):**

1. **SPEC REVIEW** (PR только со спецификациями) → 2) **STUBS GEN** → 3) **CONTRACT TESTS GREEN** → 4) **IMPL** → 5) **E2E GREEN** → 6) **MERGE**.

**Запреты:** реализация без пройденного SPEC REVIEW и без `openapi.yaml/schemas` — отклоняется.

---

## 1) Мини‑резюме брифа (для старта)

> Агент, выполни краткий парсинг `brief.md` и обнови здесь пункты. Если поле не найдено — оставь `TBD` и создай задачу.

* **Назначение:** Платформа серверной AI‑обработки фото; слоты настроек; приём `POST /ingest/{slotId}` с фото; вызов выбранного AI‑провайдера; возврат результата/504 по таймауту.
* **Ключевые сущности:** `Slot` (настройки провайдера/операции/параметров), `Job` (задача обработки), `ProviderAdapter`, `Result`.
* **UI флоу:** Авторизация → список слотов → конфиг слота (Провайдер → Операция → Параметры) → сохранение слота → просмотр статуса/результатов.
* **Синхрон/таймаут:** ожидание ответа до ~48 с; если дольше — 504, фоновая доработка и последующая выдача результата по id (если включено хранение).
* **Провайдеры (примеры):** `Gemini` (операции: Style Transfer, Combine Images, …), `Turbotext` (примерные операции). Конкретика берётся из брифа.
* **НФТ (NFR):** логирование, мониторинг, ограничение параллелизма на провайдера, ретраи до N раз, автоочистка временных файлов, TLS, базовая авторизация.

> ⚠️ Агент: **не выдумывай** поведение вне брифа. Всё новое — только через предложение изменения в `brief.md` (§9).

---

## 2) Спецификации (SDD Contract‑First)

Агент создаёт/обновляет в папке `contracts/`:

* `openapi.yaml` — HTTP‑контракты внешнего API (ingest, управление слотами, чтение статусов/результатов).
* `schemas/` — JSON Schema для `Slot`, `Job`, `Result`, `ProviderConfig`, `Error` и т. п.
* `providers/<name>.md` — специфика операций каждого провайдера (вход/выход, лимиты, таймауты, коды ошибок).

**Правило фиксации:** любая реализация контроллеров допустима **только после** обновления и коммита контрактов. Затем агент генерирует стабы и тесты.

**Чек‑лист контракта:**

* Полные статусы/коды ошибок (200/202/400/401/404/409/422/429/500/502/503/504).
* Все поля тела запроса/ответа описаны и типизированы; примеры.
* Описаны лимиты: макс. размер фото, поддерживаемые MIME, таймауты ожиданий.
* Безопасность: схема auth (например, Basic/Token), заголовки, CORS (если UI).

---

## 3) Архитектура каталогов (скелет)
Дан общий вариант скелета каталогов. По ходу разработки спецификаций скелет можно изменить соответственно потребностям. 
```
photochanger/
  app/
    api/               # эндпоинты (ingest, slots, results)
    core/              # конфиг, логгер, настройки, DI
    domain/            # модели: Slot, Job, Result; правила
    providers/         # адаптеры AI‑провайдеров (+ моки)
    queue/             # очередь задач и воркеры
    services/          # оркестраторы (ingest, results)
    storage/           # временные файлы, результаты, GC
    ui/                # веб‑интерфейс слотов (если в брифе)
    tests/             # unit/contract/e2e
  contracts/
    openapi.yaml
    schemas/
    providers/
  scripts/
    dev.sh             # локальный запуск/линт/тест
    gen_stubs.py       # генерация стаба/клиента из контрактов
  README.md
  agents.md
  brief.md             # копия брифа (ссылка на /mnt/data/brief.md)
```

> Стек UI/BE и детали плагинов берутся из брифа. Если стек не оговорён — агент обязан уточнить в PR‑описании и предложить нейтральное решение.

---

## 4) Рабочие циклы агента

### 4.1 Bootstrap (первый запуск)

1. Прочитать `brief.md`, выписать TBD‑пункты (§1).
2. **SPEC**: сгенерировать `/contracts/openapi.yaml` и JSON Schema, оформить отдельным PR **«contracts init»**.
3. **STUBS**: на основе контрактов сгенерировать стабы серверных хендлеров (без логики) и клиент; отдельный PR «stubs gen».
4. **TESTS**: добавить тесты‑контракты и базовые e2e с моками провайдеров; PR «contract tests».
5. **IMPL**: каркас адаптеров провайдеров и сервиса ingest; PR «impl skeleton».
6. **RUN**: поднять локально сервер и прогнать e2e. Только после зелёных тестов — merge.

### 4.2 Ingest‑поток (сквозной путь)

* Принять `POST /ingest/{slotId}` с изображением.
* Создать `Job`, положить в очередь, стартовать ожидание до `T_sync`.
* Воркер вызывает адаптер провайдера (по настройкам слота).
* Получен результат ≤ `T_sync` → вернуть 200 с изображением.
* Таймаут → вернуть 504; воркер доделывает; результат доступен по `job_id` (если хранение включено).

### 4.3 Провайдеры

* Каждый адаптер реализует: валидацию, трансформацию входа в формат SDK/API провайдера, маппинг ответов/ошибок в доменную модель.
* Критично: таймауты, ретраи, ограничение параллелизма, троттлинг.

### 4.4 Очистка и хранение

* Временные файлы в изолированных каталогах `storage/tmp/<job>`; авто‑GC по времени/объёму. Конфигурируемо.

---

## 5) Качество: чек‑листы

**SDD‑качество спецификаций**

* Полнота: покрыты все публичные эндпоинты, статусы, примеры.
* Непротиворечивость: термины совпадают с `brief.md`; одно значение — одно определение (Single Source of Truth).
* Проверяемость: для каждого требования есть тест.
* Изменяемость: breaking‑изменения помечены и задокументированы в `CHANGELOG`.

**Код‑стайл и безопасность**

* Линтеры включены; форматирование авто; запрет секретов в репо.
* Логи без персональных данных и без бинарных дампов картинок.
* Все внешние вызовы обёрнуты в таймаут + retry с джиттером.

**Тестирование**

* Unit: доменные правила, парсинг провайдеров, утилиты.
* Contract: валидация входов/выходов по JSON Schema, OpenAPI.
* E2E: ingest‑сценарии, таймаут 504, повторная выдача результата.
* Нагрузка: короткий стресс (N≥50 маленьких картинок, провайдеры замоканы).

**Наблюдаемость**

* Метрики: p50/p95 времени обработки; доля 504; ретраи; ошибки провайдеров по кодам.
* Трассировка: id работы в логах на всём пути.

## 6) Definition of Done (DoD)

* Контракты полные и согласованы с `brief.md`.
* Сервер поднимается локально одной командой, e2e зелёные.
* Реализованы минимум 1–2 провайдера по спецификации.
* Обработаны кейсы таймаута, ретраев, ограничение параллелизма.
* UI слотов работоспособен (если заложен в брифе).
* Настроены логи/метрики/GC, базовая авторизация и TLS‑заметка.
* Документация: `README.md` (запуск), `contracts/README.md` (как менять), `providers/*` (как добавлять нового).

---

## 7) Команды и скрипты (cheat‑sheet)

```bash
# (bash) Локальный старт всего (линт, тест, run)
./scripts/dev.sh

# (bash) Генерация стаба/клиента из контрактов
python3 ./scripts/gen_stubs.py

# (bash) Гоняем e2e (включая таймаут/504 сценарии)
pytest -m e2e -q
```

> В кодовых файлах помечать сниппеты технологией: например `# (python FastAPI)` или `// (js HTMX)` — см. правило пользователя.

---

## 8) Библиотека промптов для Codex‑агента

**8.0 SDD‑режим по умолчанию**

```
Работай в SDD‑режиме: любое изменение начинается со спецификаций.
1) Проверь /mnt/data/brief.md и действующие контракты.
2) Подготовь PR со спецификациями. Не вноси реализацию.
3) После ревью сгенерируй стабы и тесты.
4) Только после зелёных контракт‑тестов переходи к реализации.
```

**8.1 Обновить контракты из брифа**

```
Задача: синхронизировать контракты с brief.md. Действия:
1) Прочитай /mnt/data/brief.md и выпиши все публичные эндпоинты, тела запросов/ответов, статусы, таймауты.
2) Обнови contracts/openapi.yaml согласно брифу. Не придумывай неописанных полей.
3) Для каждой модели создай JSON Schema в contracts/schemas/.
4) Сгенерируй стабы контроллеров и тесты‑контракты. Не трогай реализацию.
Выход: PR «contracts sync» с списком diff‑изменений и причинами.
```

**8.2 Реализация провайдера**

```
Задача: добавить адаптер провайдера <NAME> по его разделу в brief.md.
1) Прочитай providers/<NAME>.md или секцию в брифе и выпиши входы/выходы/лимиты.
2) Реализуй класс адаптера, таймауты, ретраи, троттлинг.
3) Напиши моки и контракты ответов.
4) Добавь e2e: успешный ≤ T_sync и таймаут → 504.
```

**8.3 Сквозной ingest‑тест**

```
Прогони сценарий: POST /ingest/{slotId} с JPEG; провайдер отвечает через 10с → 200 с изображением; через 70с → 504 и сохранение результата для GET /results/{job_id}.
```

**8.4 Re‑Sync при изменении брифа**

```
1) Сравни текущие контракты с новыми требованиями.
2) Если несовместимо по API — мажорный релиз; подготовь миграцию.
3) Обнови contracts → стабы → тесты → реализация. Один PR, атомарные коммиты.
```

---

## 9) Процесс Re‑Sync с брифом

1. Вычислить diff между текущими контрактами и `brief.md`.
2. Проставить метки `breaking / non‑breaking`.
3. Обновить `openapi.yaml`, `schemas/*`, описания провайдеров.
4. Перегенерировать стабы и тесты.
5. Запустить все тесты; приложить отчёт.

---

## 10) Риски и запреты

* Нельзя логировать картинки/секреты.
* Нельзя обходить таймаут/ограничения провайдера вне описанного механизма.
* Нельзя менять схемы без обновления контрактов.
* Нельзя добавлять скрытые зависимости или фоновые демоны без описания.

---

## 11) Метрики успеха

* **SDD‑покрытие:** 100% изменений проходят через SPEC→STUBS→TESTS→IMPL.
* p95 end‑to‑end ingest ≤ заданного в брифе порога.
* Доля 504 ≤ X% при целевой нагрузке; ретраи ≤ Y%.
* Покрытие критичных путей тестами ≥ 80%.
* Время «brief→contracts→impl→green» для мелкой фичи ≤ 1 день.

## 12) Куда коммитить и как описывать PR

* Каждый PR содержит: *цель, ссылка на секцию брифа, список изменений, чек‑лист, как тестировал, скрин/лог метрик*.
* Теги PR: `contracts`, `provider`, `ingest`, `queue`, `ui`, `infra`.

---

## 13) Roadmap первых задач (sprint 0)

1. Сгенерировать `contracts/openapi.yaml` + `schemas/*` (**SPEC**).
2. Стабы API: ingest, slots, results (**STUBS**).
3. Тесты‑контракты + базовые e2e (**TESTS**).
4. Каркас очереди и воркера; первый провайдер (**IMPL**).
5. Временное хранилище и GC; метрики и логи.
6. Базовая авторизация и TLS‑заметка.
7. Базовый UI слотов (если задан в брифе).
8. Обновление `agents.md` по результатам первого прогона.

---
