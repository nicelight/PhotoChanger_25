# PhotoChanger KISS Architecture (Revised)

## 1. Общие архитектурные принципы
- **Минимум компонентов.** Один процесс FastAPI, один PostgreSQL-инстанс, локальное файловое хранилище. В проекте нет очередей, отдельных воркеров и контейнеров зависимостей.
- **Вертикальные модули.** Код разбит по срезам `ingest`, `media`, `slots`, `settings`, `stats`. Каждый модуль содержит HTTP-роуты, сервисы, инфраструктурный слой и тесты, что упрощает локальное понимание поведения.
- **Явное связывание зависимостей.** В `app/main.py` формируется `AppConfig`, создаются экземпляры сервисов модулей, и они напрямую прокидываются в роуты через `Depends`. Для тестов используется та же функция построения конфигурации с передачей фейковых адаптеров.
- **Простые контракты.** Публичные фасады имеют подробные docstring с описанием входов/выходов, README модулей фиксируют границы ответственности, чтобы LLM-помощникам было проще ориентироваться.

## 2. Модульная структура

### 2.1 ingest
- **Endpoints.** `POST /api/ingest/{slot_id}` принимает multipart-запросы с файлом, `GET /api/jobs/{job_id}` возвращает текущее состояние обработки.
- **Сервис `IngestService`.**
  - Валидирует запрос (размер, MIME, пароль слота), сохраняет файл во временное хранилище через `TempMediaStore`.
  - Определяет провайдера по настройкам слота и вызывает его драйвер внутри `asyncio.wait_for` с таймаутом `T_sync_response`. Если драйвер не укладывается, выбрасывается `asyncio.TimeoutError`, и сервис фиксирует таймаут в `job_history`.
  - Обрабатывает результат провайдера: сохраняет файл в `ResultStore`, записывает метаданные, формирует итоговый HTTP-ответ 200 с публичной ссылкой.
  - При таймауте или ошибке: обновляет статус в `job_history`, удаляет временные файлы, возвращает 504 либо 5xx.
- **Инфраструктура.** Драйверы провайдеров (`GeminiDriver`, `TurbotextDriver`) реализуют интерфейс `ProviderDriver.process(job_ctx)` и отвечают за все сетевые вызовы. Таймауты контролируются на уровне `httpx.AsyncClient`, а `IngestService` дополнительно ограничивает длительность вызова через `asyncio.wait_for`.
- **Состояние задач.** Все факты обработки (`job_history`) фиксируются в PostgreSQL. Незавершённые запросы не восстанавливаются после рестарта, что отражено в SLO.

### 2.2 media
- **Хранилища.** `TempMediaStore` и `ResultStore` работают поверх локальной файловой системы (`media/temp`, `media/results`). Пути и TTL фиксируются в `AppConfig`.
- **Жизненный цикл файлов.** Для каждого файла в таблицу `media_object` заносится `expires_at`. Сервисы проверяют TTL при чтении и удаляют просроченные файлы «лениво»: если `expires_at` в прошлом, файл удаляется сразу после обращения, запись помечается очищенной.
- **Фоновая очистка.** Вместо встроенного планировщика используется внешний cron-скрипт (`scripts/cleanup_media.py`). Он запускается системно раз в 15 минут, читает просроченные записи из БД и удаляет соответствующие файлы. FastAPI-процесс не содержит бесконечных циклов очистки.

### 2.3 slots
- **Данные.** Таблица `slot` хранит 15 статических конфигураций: идентификаторы провайдеров, шаблоны, лимиты размера.
- **Сервис `SlotConfigurator`.** Отвечает за CRUD настроек, проверяет уникальность идентификаторов, сопоставляет слоты с драйверами провайдеров. Предоставляет вспомогательные методы для генерации ingest-URL.

### 2.4 settings
- **Сервис `SettingsFacade`.** Управляет глобальными параметрами (`T_sync_response`, TTL результатов, пароли ingest, список админов).
- **Хранение секретов.** Чувствительные значения (пароли, токены провайдеров) хранятся вне БД в `.env`/переменных окружения. В таблице `settings` остаются только публичные параметры и ссылки на ключи. UI позволяет обновлять несекретные поля, а обновление секретов выполняется операционными процедурами.

### 2.5 stats
- **Отчёты.** `StatsService` читает агрегаты из `job_history` и `slot`: количество успешных/ошибочных запусков, последние результаты, распределение по провайдерам.
- **API.** REST-эндпоинты для UI возвращают агрегаты без дополнительного кэширования, упор на простоту.

## 3. Поток обработки ingest-запроса
1. Клиент DSLR Remote Pro отправляет `POST /api/ingest/{slot_id}` с файлом и токеном.
2. `IngestController` получает `IngestService` через `Depends`, создаёт `JobContext` и сохраняет исходный файл во временный каталог.
3. Сервис выбирает нужный `ProviderDriver` и вызывает его через `await asyncio.wait_for(driver.process(job_ctx), timeout=T_sync_response)`.
4. **Успешный сценарий:**
   - Драйвер возвращает `ProviderResult` до истечения таймаута.
   - Сервис сохраняет результат в `ResultStore`, обновляет `job_history` (`status='done'`, `result_path`, `result_expires_at = now + 72h`).
   - Возвращается 200 с ссылкой вида `/public/results/{job_id}`.
5. **Таймаут:**
   - `asyncio.TimeoutError` фиксируется как `status='timeout'` и `failure_reason='T_sync_response_exceeded'`.
   - Временные файлы удаляются, клиент получает 504. Поздний ответ провайдера игнорируется, потому что корутина отменена `wait_for`.
6. **Ошибка провайдера:**
   - Драйвер пробрасывает исключение, сервис пишет `status='failed'`, сохраняет стек-трейс в лог, возвращает 502/500.
7. Клиент может опросить `GET /api/jobs/{job_id}` для получения статуса в течение заданного TTL.

## 4. Данные и хранение
- **PostgreSQL:**
  - `slot` — конфигурации слотов.
  - `job_history` — история всех запусков, статусы, тайминги, ссылки на файлы, TTL.
  - `media_object` — учёт файлов (тип, путь, `expires_at`, признак очистки).
  - `settings` — глобальные параметры (без секретов) с версиями.
- **Файловая система:**
  - `media/temp/{slot_id}/{job_id}/payload.*` — исходные файлы, срок жизни = `T_sync_response`.
  - `media/results/{job_id}.{ext}` — готовые результаты, срок жизни = 72 часа.
- **Очистка:**
  - Сервисы проверяют TTL при каждом доступе и удаляют просроченные файлы на лету.
  - Системный cron (`scripts/cleanup_media.py`) выполняет бэч-очистку просроченных файлов и обновляет флаги `media_object.cleaned_at`.

## 5. Провайдеры
- **Интерфейс `ProviderDriver`.** Метод `process(job_ctx)` принимает информацию о слоте, временном файле и целевых ограничениях, возвращает `ProviderResult` с путём к локальному файлу или байтовым содержимым.
- **Реализации:**
  - `GeminiDriver` — асинхронный HTTP-клиент с трансформацией форматов. Управляет собственными таймаутами, повторов нет.
  - `TurbotextDriver` — асинхронный клиент с polling внутри одной корутины (ограничен `asyncio.wait_for`).
- **Конфигурация.** Список доступных драйверов фиксируется в `AppConfig`. Для тестов можно подменить словарь `provider_drivers` на заглушки.

## 6. Административный UI и API
- **UI.** Статические страницы или SPA в `frontend/`, обращаются к REST-API модулей. UI не организует сложных параллельных операций.
- **API.** Админ-маршруты используют тот же механизм `Depends` и сервисы модулей. Авторизация базируется на stateless токенах из `.env`.

## 7. Наблюдаемость и операционные аспекты
- **Логи.** `structlog` фиксирует события ingest, исключения провайдеров, время обработки, таймауты и факты очистки.
- **Метрики.** Prometheus-эндпоинт публикует p95 времени обработки, долю 504, размер `media/temp` и `media/results`.
- **Health-check.** `GET /healthz` проверяет подключение к БД, наличие путей файловой системы и доступность провайдерских конечных точек через лёгкие ping-запросы.

## 8. Тестовая стратегия
- **Unit-тесты.** Для сервисов модулей (ingest/media/slots/settings/stats) с использованием фейковых драйверов и временных каталогов.
- **Интеграционные тесты.** FastAPI-приложение с in-memory PostgreSQL (через `pytest-postgresql`) и временными директориями. Проверяются успешный ingest, таймауты и ошибки провайдеров.
- **Контрактные тесты провайдеров.** Мок-серверы Gemini/Turbotext, проверка поведения `ProviderDriver` при разных ответах и таймаутах.
- **Скрипт очистки.** Отдельный тест покрывает `scripts/cleanup_media.py`, проверяя удаление просроченных записей и устойчивость к отсутствующим файлам.
