#!/usr/bin/env python3
"""Generate HTTP handler stubs from the OpenAPI contract."""

from __future__ import annotations

import argparse
from dataclasses import dataclass
import sys
from pathlib import Path
from typing import Iterable, List

try:
    from yaml import safe_load
except ImportError as exc:  # pragma: no cover - dependency guard
    print(
        "PyYAML is required to generate stubs. Install it with `pip install pyyaml`.",
        file=sys.stderr,
    )
    raise


SUPPORTED_METHODS = {"get", "put", "post", "delete", "patch", "options", "head"}


@dataclass(frozen=True)
class Operation:
    """Description of an OpenAPI operation bound to a HTTP method/path."""

    method: str
    path: str
    summary: str
    description: str

    @property
    def function_name(self) -> str:
        """Return deterministic pythonic name for the stub function."""

        return f"{self.method.lower()}_{_normalise_path(self.path)}"


def _normalise_path(path: str) -> str:
    parts: List[str] = []
    for raw_part in path.strip("/").split("/"):
        if not raw_part:
            continue
        if raw_part.startswith("{") and raw_part.endswith("}"):
            raw_part = f"by_{raw_part[1:-1]}"
        safe_part = (
            raw_part.replace("-", "_")
            .replace(".", "_")
            .replace("{", "_")
            .replace("}", "_")
        ).lower()
        parts.append(safe_part)
    return "_".join(parts) or "root"


def _iter_operations(spec: dict) -> Iterable[Operation]:
    for path, path_item in spec.get("paths", {}).items():
        if not isinstance(path_item, dict):
            continue
        for method, operation in path_item.items():
            if method not in SUPPORTED_METHODS:
                continue
            if not isinstance(operation, dict):
                continue
            yield Operation(
                method=method,
                path=path,
                summary=str(operation.get("summary", "")),
                description=str(operation.get("description", "")),
            )


def _format_docstring(op: Operation) -> str:
    summary = op.summary.strip()
    description = op.description.strip()
    if summary and description:
        text = f"{summary}\n\n{description}"
    else:
        text = summary or description or f"Handler for {op.method.upper()} {op.path}."
    text = text.replace('"""', '\"\"\"')
    lines = text.splitlines()
    if len(lines) == 1:
        return f'    """{lines[0]}"""'
    formatted = ['    """']
    formatted.extend(f"    {line}" if line else "" for line in lines)
    formatted.append('    """')
    return "\n".join(formatted)


def _render_module(operations: Iterable[Operation], spec_version: str) -> str:
    operations = sorted(operations, key=lambda op: (op.path, op.method))
    header = (
        "\n".join(
            [
                '"""Auto-generated API handler stubs.',
                "",
                "Generated by scripts/gen_stubs.py.",
                f"Source contract version: {spec_version}",
                "Do not edit manually â€” regenerate the file after changing the contracts.",
                '"""',
                "",
                "from __future__ import annotations",
                "",
                "from typing import Any, Callable, Dict, Tuple",
                "",
                "__all__ = [\"ROUTE_HANDLERS\"]",
                "",
            ]
        )
    )
    body_lines: List[str] = [header]
    handler_keys: List[str] = []
    for op in operations:
        body_lines.append("")
        body_lines.append("")
        body_lines.append(f"def {op.function_name}(*args: Any, **kwargs: Any) -> None:")
        body_lines.append(_format_docstring(op))
        body_lines.append(
            f'    raise NotImplementedError("Implement handler for {op.method.upper()} {op.path}")'
        )
        handler_keys.append(
            f"    (\"{op.method.upper()}\", \"{op.path}\"): {op.function_name},"
        )
    body_lines.append("")
    body_lines.append("")
    body_lines.append("ROUTE_HANDLERS: Dict[Tuple[str, str], Callable[..., Any]] = {")
    if handler_keys:
        body_lines.extend(handler_keys)
    body_lines.append("}")
    body_lines.append("")
    return "\n".join(body_lines)


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--openapi",
        type=Path,
        default=Path(__file__).resolve().parents[1] / "spec" / "contracts" / "openapi.yaml",
        help="Path to the OpenAPI YAML contract.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path(__file__).resolve().parents[1] / "src" / "app" / "api" / "generated" / "stubs.py",
        help="Destination for the generated stub module.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print the generated module to stdout instead of writing to a file.",
    )
    args = parser.parse_args()

    with args.openapi.open("r", encoding="utf-8") as fd:
        spec = safe_load(fd)
    operations = list(_iter_operations(spec or {}))
    if not operations:
        print("No operations found in the OpenAPI spec.", file=sys.stderr)
        sys.exit(1)

    spec_version = str((spec or {}).get("info", {}).get("version", "unknown"))
    module_text = _render_module(operations, spec_version)
    if args.dry_run:
        print(module_text)
        return

    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(module_text + "\n", encoding="utf-8")
    print(f"Generated {len(operations)} handler stubs at {args.output}")


if __name__ == "__main__":
    main()
