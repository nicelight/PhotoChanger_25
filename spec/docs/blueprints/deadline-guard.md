# DeadlineGuard — дизайн контроля дедлайнов ingest-задач

## Назначение и требования
`DeadlineGuard` обеспечивает единый источник правды для дедлайна ingest-задач и очистки временных артефактов. Он синхронизирует
API, воркеров и хранилища вокруг заранее зафиксированного `Job.expires_at`, чтобы:
- гарантировать, что ожидание синхронного ответа не превышает `T_sync_response` (настраивается в диапазоне 45–60 с);
- удалить исходные медиа не позднее `T_ingest_ttl = min(T_sync_response, T_public_link_ttl)`;
- выдержать TTL публичных ссылок `T_public_link_ttl = clamp(T_sync_response, 45, 60)` без рассинхронизации с дедлайном ingest.【F:Docs/brief.md†L19-L137】

## Источники конфигурации дедлайнов
| Параметр             | Источник конфигурации                    | Назначение |
|----------------------|------------------------------------------|------------|
| `T_sync_response`    | `app_settings["ingest.sync_response_timeout_sec"]` (по умолчанию 48 с, допустимый диапазон 45–60 с) | Верхняя граница ожидания HTTP-ответа ingest API и минимальная составляющая расчёта `T_job_deadline`. |
| `T_ingest_ttl`       | `app_settings["media.ingest_ttl_sec"] = min(T_sync_response, T_public_link_ttl)` (по умолчанию 48 с) | TTL исходных файлов во временном хранилище `payload`. |
| `T_public_link_ttl`  | `app_settings["media.public_link_ttl_sec"] = clamp(T_sync_response, 45, 60)` | Жёсткий лимит времени жизни публичных ссылок и иных внешних артефактов. Используется при расчёте `T_job_deadline`. |

Загрузка значений происходит через слой конфигурации приложения при старте. `DeadlineGuard` инкапсулирует доступ к параметрам, сохраняя текущие значения в кешируемой структуре (с инвалидирующим флагом при обновлении `app_settings`). Все компоненты получают дедлайн только через публичные методы `DeadlineGuard`.

Дополнительно сервис вычисляет агрегированный параметр `T_job_deadline = max(T_sync_response, T_media_limit_max)`, где `T_media_limit_max` определяется на основании активных временных хранилищ. Это избавляет от необходимости держать отдельные таймеры для публичных ссылок и гарантирует, что `job.expires_at` не короче самого длинного артефактного окна.

## Модель данных: `Job.expires_at`
- При создании записи `Job` (этап постановки в очередь) фиксируется поле `expires_at = created_at + T_job_deadline`, где `T_job_deadline = max(T_sync_response, T_media_limit_max)` и `T_media_limit_max` — максимальный из актуальных лимитов временных артефактов (для публичных ссылок используется `T_public_link_ttl`).
- Поле хранится в БД и не изменяется после создания, чтобы API и воркеры ссылались на одну и ту же отметку времени.
- Для обратной совместимости представления `Job` в административных/статусных API расширяются полем `expires_at`; существующие клиенты получают значение «read-only».
- Дополнительные временные объекты (`payload_path`, `media_object`) используют `job.expires_at` как верхнюю границу собственного TTL.

## Интерфейс DeadlineGuard
`DeadlineGuard` предоставляет единые хелперы:
- `deadline_guard.for_job(job_id)` → возвращает `expires_at` и расчёт оставшегося времени (`remaining_ms`).
- `deadline_guard.attach(job)` → вычисляет `expires_at` перед вставкой и прокидывает значение во все downstream-компоненты.
- `deadline_guard.should_abort(job)` → проверяет наступление дедлайна (используется API/воркерами для принятия решения об отмене).
- `deadline_guard.lease(ttl_kind, created_at)` → вычисляет TTL для временного артефакта через формулу `min(created_at + T_media_limit, job.expires_at)`; при текущих настройках артефакт успевает прожить полный собственный лимит.
- `deadline_guard.gc_cursor()` → предоставляет временную метку для периодических задач очистки.

Хелпер реализован как лёгкий сервис (внутренняя библиотека + периодический cron/worker), без отдельного сетевого процесса.

## Политика TTL временных артефактов
Для всех временных сущностей, ссылающихся на `Job` (`payload`, промежуточный кэш, публичные ссылки), применяется стратегия:
```
artifact_expires_at = min(created_at + T_media_limit, job.expires_at)
```
При выбранном `T_job_deadline` значение `job.expires_at` всегда ≥ `created_at + T_media_limit`, поэтому артефакт отрабатывает полный собственный лимит, а очистка остаётся синхронизированной с дедлайном задачи.
Примеры:
- Исходный `payload`: `T_media_limit = T_ingest_ttl`, TTL совпадает с `job.expires_at` и не выходит за окно синхронного ответа.
- Публичная ссылка Turbotext: `T_media_limit = T_public_link_ttl`; ссылка гарантированно доступна полный сконфигурированный TTL, но не дольше `job.expires_at`.
- Промежуточные файлы провайдера: используют собственный лимит (если есть) и дополнительно ограничены `job.expires_at`.

## Интеграция с API и воркерами
### Ingest API
1. При создании `Job` вызывает `deadline_guard.attach()` и сохраняет `expires_at`.
2. Цикл ожидания синхронного ответа использует `job.expires_at` вместо локального таймера. Если время истекло — возвращает 504 и инициирует отмену.
3. Ответ API (успех/404/504) следует бинарному контракту ingest и не содержит `expires_at`; клиентский UI получает дедлайн через статусные/административные эндпоинты.

### Worker
1. При выборке задачи воркер получает `job.expires_at` и рассчитывает оставшееся время для вызова провайдера и ретраев.
2. После каждого шага (вызов провайдера, обработка async-id) проверяет `deadline_guard.should_abort()`. При наступлении дедлайна отменяет запросы, очищает временные данные через `deadline_guard`.
3. Очистка файлов (`payload_path`, публичные ссылки) вызывается через унифицированные хелперы TTL.

### Очистка и периодические задачи
- Периодическая задача `deadline_guard.gc()` просматривает `Job` и связанные артефакты, у которых `expires_at < now`, и инициирует удаление.
- Для публичных ссылок `deadline_guard` вызывает существующий механизм удаления, передавая дату `min(created_at + T_public_link_ttl, job.expires_at)`; с учётом `T_job_deadline` фактическая жизнь ссылки равна `T_public_link_ttl`.

## План внедрения
1. Обновить схемы данных и миграции: добавить `Job.expires_at`, проставлять значение при вставке.
2. Расширить контракты API (`Job` в административных/статусных эндпоинтах) полем `expires_at`; ответы ingest остаются без дополнительных полей.
3. Реализовать сервис `DeadlineGuard` (интерфейсы выше) и заменить разрозненные таймеры API/воркеров на обращения к нему.
4. Адаптировать механизмы временных хранилищ под стратегию `min(created_at + T_media_limit, job.expires_at)`.
5. Добавить периодическую задачу/кронометку очистки, использующую `deadline_guard.gc_cursor()`.

Такой дизайн даёт минимально необходимую централизованную точку для дедлайнов без усложнения архитектуры и соответствует требованиям брифа по контролю `T_sync_response` и TTL медиа.【F:Docs/brief.md†L19-L132】
