# Контроль дедлайнов ingest-задач

## Назначение
Дедлайн задачи (`Job.expires_at`) и связанные TTL вычисляются напрямую в момент создания `Job`. Централизованный сервис больше не требуется: компоненты используют общий набор функций доменного слоя, который опирается на конфигурацию приложения.

## Источники конфигурации
| Параметр | Источник | Назначение |
|---|---|---|
| `T_sync_response` | `app_settings["ingest.sync_response_timeout_sec"]` (по умолчанию 48 с, допустимый диапазон 45–60 с) | Верхняя граница ожидания HTTP-ответа ingest API и минимальная составляющая расчёта `T_job_deadline`. |
| `T_public_link_ttl` | `app_settings["media.public_link_ttl_sec"] = clamp(T_sync_response, 45, 60)` | Жёсткий лимит жизни публичных ссылок и других внешних артефактов. |
| `T_ingest_ttl` | `app_settings["media.ingest_ttl_sec"] = min(T_sync_response, T_public_link_ttl)` | TTL исходных файлов во временном хранилище `payload`. |

Значения подгружаются конфигурацией приложения. При изменении настроек новые задачи используют актуальные параметры без миграций.

## Расчёт дедлайна
* `T_job_deadline = max(T_sync_response, T_public_link_ttl)`.
* При вставке записи в таблицу `job` бекенд устанавливает `job.expires_at = job.created_at + T_job_deadline`.
* Значение не изменяется и доступно всем компонентам. Остаток времени вычисляется как `remaining_ms = floor((expires_at - now) * 1000)`.

## TTL временных артефактов
Для всех временных сущностей действует формула:
```
artifact_expires_at = min(job.expires_at, created_at + T_media_limit)
```
где `T_media_limit` — конкретный лимит артефакта (`T_ingest_ttl`, `T_public_link_ttl` и т. д.). Благодаря выбранному `T_job_deadline` временные публичные ссылки живут полный `T_public_link_ttl`, а payload не выходит за пределы синхронного окна ожидания.

## Доменные функции
Доменный слой обязан предоставить общий набор расчётов дедлайнов и TTL, который опирается на значения конфигурации. Минимальный
набор функций:
* `calculate_job_expires_at(created_at, sync_timeout, public_link_ttl)` — вычисляет значение `job.expires_at`.
* `calculate_deadline_info(expires_at, *, now)` — возвращает остаток времени и признак истечения дедлайна.
* `calculate_artifact_expiry(created_at, job_expires_at, limit_seconds)` — определяет срок жизни временных артефактов (payload,
  публичные ссылки и т. д.).

API, воркеры и механизмы очистки используют эти функции напрямую, без посредника. Конкретная реализация остаётся внутри доменного
слоя и не требует отдельного сервиса.

## Интеграция компонентов
* **Ingest API** рассчитывает `expires_at` при создании `Job` и использует его в цикле ожидания (`min(now, expires_at)` → 504 по наступлении дедлайна).
* **Worker** берёт `expires_at` вместе с задачей, вычисляет остаток времени перед обращением к провайдеру и прекращает обработку по истечении дедлайна.
* **Очистка артефактов** получает временные отметки через `calculate_artifact_expiry` и удаляет payload/публичные ссылки, как только они истекают. Периодические задачи берут `expires_at` из `Job` и не полагаются на дополнительные таблицы.

## Миграции и конфигурация
Специальных миграций не требуется: поле `job.expires_at` уже присутствует в схеме, а настройки `app_settings` остаются источником значения. Удаление конфигурации, связанной с прежним сервисом, ограничивается очисткой неиспользуемых ключей.

Такой подход соответствует требованиям брифа: дедлайн синхронизирован с `T_sync_response`, TTL публичных ссылок не сокращается, а конфигурация остаётся единственным источником правды.
