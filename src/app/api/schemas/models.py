"""Auto-generated Pydantic models derived from spec/contracts/schemas.

Generated by scripts/gen_stubs.py. Do not edit manually.
"""

from __future__ import annotations

from datetime import date, datetime
from pydantic import BaseModel, ConfigDict, Field
from typing import Any, Literal
from uuid import UUID

__all__ = [
    "SlotId",
    "SlotIdentifier",
    "AuthToken",
    "ErrorResponse",
    "ErrorResponseError",
    "GlobalStatsMetric",
    "GlobalStatsResponse",
    "GlobalStatsResponseSummary",
    "GlobalStatsResponseMeta",
    "IngestRequest",
    "Job",
    "JobAdminView",
    "JobDeadline",
    "JobDetailResponse",
    "JobListResponse",
    "JobListResponseMeta",
    "JobMetrics",
    "LoginRequest",
    "LoginResponse",
    "MediaCachePurgeRequest",
    "MediaCachePurgeResponse",
    "MediaCacheSettings",
    "MediaObject",
    "MediaRegisterRequest",
    "ProviderConfig",
    "ProviderListResponse",
    "ProviderOperation",
    "ProviderSummary",
    "Result",
    "Settings",
    "SettingsDslrPasswordStatus",
    "SettingsIngestConfig",
    "SettingsProviderKeyStatus",
    "SettingsProviderKeyUpdate",
    "SettingsResponse",
    "SettingsUpdateRequest",
    "SettingsUpdateRequestDslrPassword",
    "SettingsUpdateRequestIngest",
    "Slot",
    "SlotListResponse",
    "SlotListResponseMeta",
    "SlotStatsMetric",
    "SlotStatsResponse",
    "SlotStatsResponseRange",
    "SlotStatsResponseSummary",
    "SlotUpdateRequest",
    "SlotUpdateResponse",
    "TemplateMediaObject",
    "TemplateMediaRegisterRequest",
]

SlotId = Literal[
    "slot-001",
    "slot-002",
    "slot-003",
    "slot-004",
    "slot-005",
    "slot-006",
    "slot-007",
    "slot-008",
    "slot-009",
    "slot-010",
    "slot-011",
    "slot-012",
    "slot-013",
    "slot-014",
    "slot-015",
]
"""Допустимый статический идентификатор ingest-слота."""
SlotIdentifier = SlotId
"""Backwards compatible alias for SlotId."""


class AuthToken(BaseModel):
    """JWT токен доступа, выдаваемый после успешной аутентификации"""

    model_config = ConfigDict(extra="forbid")
    access_token: str = Field(..., description="JWT токен доступа")
    token_type: Literal["bearer"] = Field(..., description="Тип токена")
    expires_in_sec: int = Field(..., description="Время жизни токена в секундах", ge=1)


class ErrorResponse(BaseModel):
    """Schema for ErrorResponse"""

    model_config = ConfigDict(extra="forbid")
    error: ErrorResponseError = Field(...)


class ErrorResponseError(BaseModel):
    """Schema for ErrorResponseError"""

    model_config = ConfigDict(extra="forbid")
    code: str = Field(..., description="Машиночитаемый код ошибки в snake_case")
    message: str = Field(..., description="Человекочитаемое описание проблемы")
    details: dict[str, Any] | None = Field(
        None, description="Дополнительные детали ошибки"
    )


class GlobalStatsMetric(BaseModel):
    """Schema for GlobalStatsMetric"""

    model_config = ConfigDict(extra="forbid")
    period_start: date = Field(...)
    period_end: date = Field(...)
    success: int = Field(..., ge=0)
    timeouts: int = Field(..., ge=0)
    provider_errors: int = Field(..., ge=0)
    cancelled: int = Field(..., ge=0)
    errors: int = Field(..., ge=0)
    ingest_count: int = Field(..., ge=0)


class GlobalStatsResponse(BaseModel):
    """Schema for GlobalStatsResponse"""

    model_config = ConfigDict(extra="forbid")
    summary: GlobalStatsResponseSummary = Field(...)
    data: list[GlobalStatsMetric] = Field(...)
    meta: GlobalStatsResponseMeta = Field(...)


class GlobalStatsResponseSummary(BaseModel):
    """Schema for GlobalStatsResponseSummary"""

    model_config = ConfigDict(extra="forbid")
    total_runs: int = Field(..., ge=0)
    timeouts: int = Field(..., ge=0)
    provider_errors: int = Field(..., ge=0)
    cancelled: int = Field(..., ge=0)
    errors: int = Field(..., ge=0)
    ingest_count: int = Field(..., ge=0)


class GlobalStatsResponseMeta(BaseModel):
    """Schema for GlobalStatsResponseMeta"""

    model_config = ConfigDict(extra="forbid")
    page: int = Field(..., ge=1)
    page_size: int = Field(..., ge=1)
    total: int = Field(..., ge=0)


class IngestRequest(BaseModel):
    """Schema for IngestRequest"""

    password: str = Field(
        ...,
        description="Глобальный пароль ingest, проверяемый на сервере",
        min_length=1,
    )
    fileToUpload: str = Field(..., description="Основной файл изображения")


class Job(BaseModel):
    """Schema for Job"""

    model_config = ConfigDict(extra="forbid")
    id: UUID = Field(...)
    slot_id: Literal[
        "slot-001",
        "slot-002",
        "slot-003",
        "slot-004",
        "slot-005",
        "slot-006",
        "slot-007",
        "slot-008",
        "slot-009",
        "slot-010",
        "slot-011",
        "slot-012",
        "slot-013",
        "slot-014",
        "slot-015",
    ] = Field(..., description="Идентификатор слота, из которого была создана задача.")
    status: Literal["pending", "processing"] = Field(
        ..., description="Промежуточное состояние обработки до финализации."
    )
    is_finalized: bool = Field(
        ..., description="Признак того, что задача завершена (успех или ошибка)."
    )
    failure_reason: Literal["timeout", "provider_error", "cancelled"] | None = Field(
        None,
        description="Причина неуспешного завершения. Присутствует только если is_finalized = true и обработка не удалась.",
    )
    provider_job_reference: str | None = Field(
        None,
        description="Опциональный идентификатор очереди внешнего провайдера (например, `queueid` Turbotext для polling).",
    )
    payload_path: str | None = Field(
        None, description="Путь к исходному ingest-файлу во временном хранилище."
    )
    result_file_path: str | None = Field(
        None,
        description="Относительный путь к итоговому файлу результата в MEDIA_ROOT/results.",
    )
    result_inline_base64: str | None = Field(
        None,
        description="Временная base64-строка результата для синхронного ответа ingest; очищается сразу после отправки HTTP 200 или таймаута.",
    )
    result_mime_type: str | None = Field(
        None, description="MIME-тип итогового изображения."
    )
    result_size_bytes: int | None = Field(
        None, description="Размер результата в байтах.", ge=0
    )
    result_checksum: str | None = Field(
        None, description="Контрольная сумма содержимого (например, SHA-256 в hex)."
    )
    result_expires_at: datetime | None = Field(
        None,
        description="Момент автоочистки итогового файла (`finalized_at + T_result_retention`, по умолчанию 72 часа).",
    )
    expires_at: datetime = Field(
        ...,
        description="Единый дедлайн задачи: фиксируется при создании как created_at + T_sync_response и используется API/воркерами для контроля таймаутов.",
    )
    created_at: datetime = Field(...)
    updated_at: datetime = Field(...)
    finalized_at: datetime | None = Field(
        None, description="Момент фиксации финального состояния."
    )


class JobAdminView(BaseModel):
    """Агрегированное представление задачи для административного мониторинга."""

    model_config = ConfigDict(extra="forbid")
    job: Job = Field(
        ..., description="Базовая запись очереди, совпадает с контрактом Job."
    )
    deadline: JobDeadline = Field(
        ...,
        description="Единый дедлайн и остаток времени, вычисленные на основе `job.expires_at`.",
    )
    metrics: JobMetrics = Field(
        ..., description="Сводные тайминги ожидания и обработки."
    )


class JobDeadline(BaseModel):
    """Schema for JobDeadline"""

    model_config = ConfigDict(extra="forbid")
    expires_at: datetime = Field(
        ...,
        description="Момент, когда задача обязана быть финализирована согласно расчёту `created_at + T_sync_response`.",
    )
    remaining_ms: int = Field(
        ...,
        description="Оставшееся время до дедлайна в миллисекундах (может быть отрицательным, если дедлайн уже истёк).",
    )
    is_expired: bool = Field(..., description="Признак того, что дедлайн уже наступил.")


class JobDetailResponse(BaseModel):
    """Подробное агрегированное представление задачи: те же блоки job/deadline/metrics, что и в списке, но для одного идентификатора."""


class JobListResponse(BaseModel):
    """Ответ административного списка задач. Содержит агрегированные представления задач и постраничную мета-информацию, рассчитанные на основе `job.expires_at`."""

    model_config = ConfigDict(extra="forbid")
    data: list[JobAdminView] = Field(
        ...,
        description="Список агрегированных представлений задач очереди.",
        min_items=0,
    )
    meta: JobListResponseMeta = Field(
        ...,
        description="Параметры пагинации, совпадающие с контрактом административного UI.",
    )


class JobListResponseMeta(BaseModel):
    """Параметры пагинации, совпадающие с контрактом административного UI."""

    model_config = ConfigDict(extra="forbid")
    page: int = Field(..., description="Текущая страница выборки.", ge=1)
    page_size: int = Field(
        ..., description="Количество элементов на странице.", ge=1, le=100
    )
    total: int = Field(
        ..., description="Общее количество задач, удовлетворяющих фильтрам.", ge=0
    )


class JobMetrics(BaseModel):
    """Schema for JobMetrics"""

    model_config = ConfigDict(extra="forbid")
    queue_wait_ms: int | None = Field(
        ...,
        description="Сколько миллисекунд задача провела в очереди до начала обработки.",
        ge=0,
    )
    processing_ms: int | None = Field(
        ...,
        description="Продолжительность обработки воркером. null, если обработка ещё не началась или не измерена.",
        ge=0,
    )
    total_elapsed_ms: int | None = Field(
        ...,
        description="Общее время от постановки в очередь до текущего момента или финализации.",
        ge=0,
    )


class LoginRequest(BaseModel):
    """Schema for LoginRequest"""

    model_config = ConfigDict(extra="forbid")
    username: str = Field(
        ..., description="Имя предустановленного пользователя", min_length=1
    )
    password: str = Field(..., description="Пароль пользователя", min_length=1)


class LoginResponse(BaseModel):
    """Ответ авторизации повторно использует контракт AuthToken"""


class MediaCachePurgeRequest(BaseModel):
    """Schema for MediaCachePurgeRequest"""

    model_config = ConfigDict(extra="forbid")
    scope: Literal["full", "media_objects"] | None = Field(
        None,
        description="Режим очистки: полная (Result + media_object) или только временные media_object",
    )


class MediaCachePurgeResponse(BaseModel):
    """Schema for MediaCachePurgeResponse"""

    model_config = ConfigDict(extra="forbid")
    status: Literal["queued_for_gc"] = Field(
        ..., description="Статус постановки задания очистки"
    )
    scope: Literal["full", "media_objects"] = Field(
        ..., description="Режим, с которым запланирована очистка"
    )
    job_id: str = Field(..., description="Идентификатор фонового задания очистки")
    expires_cutoff: datetime = Field(
        ...,
        description="Пороговый момент времени, до которого будут удалены устаревшие сущности",
    )


class MediaCacheSettings(BaseModel):
    """Schema for MediaCacheSettings"""

    model_config = ConfigDict(extra="forbid")
    processed_media_ttl_hours: Literal[72] | None = Field(
        None, description="Фиксированный срок хранения итоговых Result в часах"
    )
    public_link_ttl_sec: int | None = Field(
        None,
        description="Срок жизни временных публичных ссылок в секундах (равен T_sync_response)",
        ge=45,
        le=60,
    )


class MediaObject(BaseModel):
    """Schema for MediaObject"""

    model_config = ConfigDict(extra="forbid")
    id: UUID = Field(..., description="Идентификатор временного медиа")
    public_url: str = Field(..., description="Публичный URL для скачивания")
    expires_at: datetime = Field(
        ...,
        description="Момент истечения ссылки (`created_at + T_public_link_ttl`, где `T_public_link_ttl = T_sync_response`)",
    )
    mime: str | None = Field(
        None, description="MIME-тип загруженного файла", pattern="^image/"
    )
    size_bytes: int | None = Field(None, description="Размер файла в байтах", ge=0)
    job_id: UUID | None = Field(
        None, description="Идентификатор Job, для которой зарегистрирован файл"
    )


class MediaRegisterRequest(BaseModel):
    """Загрузка временного файла. TTL ссылки вычисляется как T_sync_response секунд и не передаётся в запросе"""

    model_config = ConfigDict(extra="forbid")
    file: str = Field(
        ..., description="Изображение JPEG/PNG/WEBP, загружаемое во временное хранилище"
    )
    job_id: UUID | None = Field(
        None, description="Идентификатор задачи обработки, к которой привязан файл"
    )


class ProviderConfig(BaseModel):
    """Schema for ProviderConfig"""

    model_config = ConfigDict(extra="forbid")
    id: str = Field(..., description="Идентификатор провайдера")
    name: str = Field(..., description="Отображаемое имя провайдера")
    requires_public_media: bool = Field(
        ..., description="Нужно ли публичное медиа-хранилище для операций"
    )
    operations: list[ProviderOperation] = Field(...)


class ProviderListResponse(BaseModel):
    """Schema for ProviderListResponse"""

    model_config = ConfigDict(extra="forbid")
    providers: list[ProviderSummary] = Field(...)


class ProviderOperation(BaseModel):
    """Schema for ProviderOperation"""

    model_config = ConfigDict(extra="forbid")
    id: str = Field(..., description="Идентификатор операции")
    name: str = Field(..., description="Отображаемое имя операции")
    needs: list[str] = Field(
        ..., description="UI требования к полям (например, prompt, reference_image)"
    )
    schema_ref: str = Field(..., description="Путь к JSON Schema параметров операции")


class ProviderSummary(BaseModel):
    """Schema for ProviderSummary"""

    model_config = ConfigDict(extra="forbid")
    id: str = Field(..., description="Машиночитаемый идентификатор провайдера")
    name: str = Field(..., description="Отображаемое имя провайдера")


class Result(BaseModel):
    """Метаданные итогового файла обработки, возвращаемые административным API"""

    model_config = ConfigDict(extra="forbid")
    job_id: UUID = Field(
        ..., description="Идентификатор Job, по которому получен результат"
    )
    thumbnail_url: str = Field(..., description="URL превью изображения для галереи UI")
    download_url: str = Field(
        ...,
        description="Публичная ссылка на итоговый файл (`GET /public/results/{job_id}`)",
    )
    completed_at: datetime = Field(..., description="Метка времени финализации задачи")
    result_expires_at: datetime = Field(
        ...,
        description="Момент истечения TTL итогового файла (`finalized_at + T_result_retention = 72h`)",
    )
    mime: str = Field(
        ..., description="MIME-тип итогового изображения", pattern="^image/"
    )
    size_bytes: int | None = Field(
        None, description="Размер итогового файла в байтах, если доступен", ge=0
    )


class Settings(BaseModel):
    """Глобальные настройки платформы и состояние секретов"""

    model_config = ConfigDict(extra="forbid")
    dslr_password: SettingsDslrPasswordStatus = Field(...)
    provider_keys: dict[str, SettingsProviderKeyStatus] = Field(
        ...,
        description="Секреты и публичные параметры AI-провайдеров, индексированные по идентификатору",
    )
    ingest: SettingsIngestConfig = Field(...)
    media_cache: MediaCacheSettings = Field(...)


class SettingsDslrPasswordStatus(BaseModel):
    """Schema for SettingsDslrPasswordStatus"""

    model_config = ConfigDict(extra="forbid")
    is_set: bool = Field(
        ...,
        description="Признак того, что DSLR-пароль установлен (хэш присутствует в хранилище)",
    )
    updated_at: datetime | None = Field(
        None,
        description="Момент последнего обновления значения либо null, если пароль не задавался",
    )
    updated_by: str | None = Field(
        None, description="Логин пользователя, выполнившего обновление значения"
    )


class SettingsIngestConfig(BaseModel):
    """Schema for SettingsIngestConfig"""

    model_config = ConfigDict(extra="forbid")
    sync_response_timeout_sec: int = Field(
        ...,
        description="Таймаут синхронного ожидания ingest в секундах. Настраивается администратором и распространяется на все связанные TTL",
        ge=45,
        le=60,
    )
    ingest_ttl_sec: int = Field(
        ...,
        description="Вычисленный TTL исходных payload: T_sync_response",
        ge=45,
        le=60,
    )


class SettingsProviderKeyStatus(BaseModel):
    """Schema for SettingsProviderKeyStatus

    Additional properties follow schema-defined types."""

    model_config = ConfigDict(extra="allow")
    is_configured: bool = Field(
        ...,
        description="Показывает, что секреты и обязательные параметры для провайдера заданы",
    )
    updated_at: datetime | None = Field(
        None,
        description="Момент последнего обновления секрета или null, если значение ещё не задавалось",
    )
    updated_by: str | None = Field(
        None, description="Логин пользователя, обновившего секрет"
    )


class SettingsProviderKeyUpdate(BaseModel):
    """Schema for SettingsProviderKeyUpdate

    Additional properties follow schema-defined types."""

    model_config = ConfigDict(extra="allow")
    api_key: str | None = Field(
        None, description="Новый API-ключ провайдера", min_length=1
    )


class SettingsResponse(BaseModel):
    """Ответ администратора использует базовую схему Settings"""


class SettingsUpdateRequest(BaseModel):
    """Schema for SettingsUpdateRequest"""

    model_config = ConfigDict(extra="forbid")
    dslr_password: SettingsUpdateRequestDslrPassword | None = Field(
        None,
        description="Секция обновления DSLR-пароля. Передача значения перехеширует пароль",
    )
    provider_keys: dict[str, SettingsProviderKeyUpdate] | None = Field(
        None,
        description="Карточки провайдеров для обновления секретов и публичных параметров",
    )
    ingest: SettingsUpdateRequestIngest | None = Field(
        None,
        description="Настройка таймаута синхронного ожидания ingest и связанных TTL",
    )


class SettingsUpdateRequestDslrPassword(BaseModel):
    """Секция обновления DSLR-пароля. Передача значения перехеширует пароль"""

    model_config = ConfigDict(extra="forbid")
    value: str = Field(
        ...,
        description="Новый пароль, который будет захеширован и сохранён для DSLR Remote Pro",
        min_length=1,
    )


class SettingsUpdateRequestIngest(BaseModel):
    """Настройка таймаута синхронного ожидания ingest и связанных TTL"""

    model_config = ConfigDict(extra="forbid")
    sync_response_timeout_sec: int = Field(
        ..., description="Новое значение `T_sync_response` в секундах", ge=45, le=60
    )


class Slot(BaseModel):
    """Schema for Slot"""

    model_config = ConfigDict(extra="forbid")
    id: str = Field(
        ...,
        description="Идентификатор статического ingest-слота",
        pattern="^slot-[0-9]{3}$",
    )
    name: str = Field(..., description="Отображаемое имя слота")
    provider_id: str = Field(..., description="Идентификатор провайдера")
    operation_id: str = Field(..., description="Идентификатор операции провайдера")
    settings_json: dict[str, Any] = Field(
        ..., description="Параметры, сериализованные для провайдера"
    )
    last_reset_at: datetime | None = Field(
        None, description="Метка последнего сброса статистики"
    )
    created_at: datetime = Field(..., description="Момент создания слота")
    updated_at: datetime = Field(
        ..., description="Момент последнего обновления настроек"
    )
    recent_results: list[Result] | None = Field(
        None,
        description="Последние успешные результаты этого слота (не более 10 элементов, сортировка по `completed_at` убыванию).",
    )


class SlotListResponse(BaseModel):
    """Schema for SlotListResponse"""

    model_config = ConfigDict(extra="forbid")
    data: list[Slot] = Field(...)
    meta: SlotListResponseMeta = Field(...)


class SlotListResponseMeta(BaseModel):
    """Schema for SlotListResponseMeta"""

    model_config = ConfigDict(extra="forbid")
    total: int = Field(..., description="Количество доступных слотов", ge=0)


class SlotStatsMetric(BaseModel):
    """Schema for SlotStatsMetric"""

    model_config = ConfigDict(extra="forbid")
    period_start: datetime | date = Field(
        ..., description="Начало агрегируемого интервала"
    )
    period_end: datetime | date = Field(
        ..., description="Конец агрегируемого интервала"
    )
    success: int = Field(..., ge=0)
    timeouts: int = Field(..., ge=0)
    provider_errors: int = Field(..., ge=0)
    cancelled: int = Field(..., ge=0)
    errors: int = Field(..., ge=0)
    ingest_count: int = Field(..., ge=0)


class SlotStatsResponse(BaseModel):
    """Schema for SlotStatsResponse"""

    model_config = ConfigDict(extra="forbid")
    slot_id: Literal[
        "slot-001",
        "slot-002",
        "slot-003",
        "slot-004",
        "slot-005",
        "slot-006",
        "slot-007",
        "slot-008",
        "slot-009",
        "slot-010",
        "slot-011",
        "slot-012",
        "slot-013",
        "slot-014",
        "slot-015",
    ] = Field(
        ..., description="Идентификатор слота, для которого рассчитана статистика"
    )
    range: SlotStatsResponseRange = Field(...)
    summary: SlotStatsResponseSummary = Field(...)
    metrics: list[SlotStatsMetric] = Field(...)


class SlotStatsResponseRange(BaseModel):
    """Schema for SlotStatsResponseRange"""

    model_config = ConfigDict(extra="forbid")
    from_: datetime | date = Field(
        ..., alias="from", description="Начало выбранного диапазона статистики"
    )
    to: datetime | date = Field(
        ..., description="Конец выбранного диапазона статистики"
    )
    group_by: Literal["hour", "day", "week"] = Field(
        ..., description="Гранулярность агрегирования метрик"
    )


class SlotStatsResponseSummary(BaseModel):
    """Schema for SlotStatsResponseSummary"""

    model_config = ConfigDict(extra="forbid")
    title: str | None = Field(...)
    success: int = Field(..., ge=0)
    timeouts: int = Field(..., ge=0)
    provider_errors: int = Field(..., ge=0)
    cancelled: int = Field(..., ge=0)
    errors: int = Field(..., ge=0)
    ingest_count: int = Field(..., ge=0)
    last_reset_at: datetime | None = Field(...)


class SlotUpdateRequest(BaseModel):
    """Schema for SlotUpdateRequest"""

    model_config = ConfigDict(extra="forbid")
    name: str = Field(..., description="Новое имя слота", min_length=1)
    provider_id: str = Field(..., description="Идентификатор провайдера", min_length=1)
    operation_id: str = Field(
        ..., description="Идентификатор операции провайдера", min_length=1
    )
    settings_json: dict[str, Any] = Field(..., description="Конфигурация операции")
    updated_at: datetime | None = Field(
        None, description="Текущая версия слота, полученная из последнего чтения"
    )


class SlotUpdateResponse(BaseModel):
    """Schema for SlotUpdateResponse"""

    model_config = ConfigDict(extra="forbid")
    id: str = Field(..., description="Идентификатор слота", pattern="^slot-[0-9]{3}$")
    updated_at: datetime = Field(..., description="Новая метка времени обновления")


class TemplateMediaObject(BaseModel):
    """Schema for TemplateMediaObject"""

    model_config = ConfigDict(extra="forbid")
    id: UUID = Field(..., description="Идентификатор шаблонного медиа")
    slot_id: Literal[
        "slot-001",
        "slot-002",
        "slot-003",
        "slot-004",
        "slot-005",
        "slot-006",
        "slot-007",
        "slot-008",
        "slot-009",
        "slot-010",
        "slot-011",
        "slot-012",
        "slot-013",
        "slot-014",
        "slot-015",
    ] = Field(..., description="Слот, с которым связана загрузка")
    setting_key: str = Field(
        ..., description="Ключ настройки, к которому привязан шаблон"
    )
    label: str | None = Field(
        None, description="Необязательный человекочитаемый ярлык шаблона"
    )
    checksum: str | None = Field(
        None,
        description="Контрольная сумма файла (например, SHA-256 в hex)",
        pattern="^[A-Fa-f0-9]{64}$",
    )
    mime: str = Field(..., description="MIME-тип сохранённого файла")
    size_bytes: int = Field(..., description="Размер файла в байтах", ge=0)
    uploaded_by: str | None = Field(
        None, description="Администратор, загрузивший шаблон"
    )
    created_at: datetime = Field(..., description="Момент загрузки шаблона")


class TemplateMediaRegisterRequest(BaseModel):
    """Schema for TemplateMediaRegisterRequest"""

    model_config = ConfigDict(extra="forbid")
    file: str = Field(
        ...,
        description="Файл шаблона (JPEG/PNG/WEBP/HEIC/HEIF) для постоянного хранения",
    )
    slot_id: Literal[
        "slot-001",
        "slot-002",
        "slot-003",
        "slot-004",
        "slot-005",
        "slot-006",
        "slot-007",
        "slot-008",
        "slot-009",
        "slot-010",
        "slot-011",
        "slot-012",
        "slot-013",
        "slot-014",
        "slot-015",
    ] = Field(..., description="Идентификатор слота, к которому привязывается шаблон")
    setting_key: str = Field(
        ...,
        description="Ключ настройки в Slot.settings_json, который ссылается на шаблон",
    )
    label: str | None = Field(
        None, description="Человекочитаемое название шаблона для UI"
    )
    replace: bool | None = Field(
        None, description="Флаг замены существующей привязки шаблона"
    )
