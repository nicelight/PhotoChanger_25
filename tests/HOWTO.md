### 1. Как работают тесты Фазы 3

- **Контрактные тесты API** прогоняют заранее описанные сценарии по каждому публичному эндпоинту (`POST /ingest/{slotId}`, админские и публичные GET/PUT) и сверяют ответы с OpenAPI и JSON Schema. В позитивных сценариях проверяется «счастливый путь», в негативных — коды ошибок, валидация, ограничения авторизации и ротации ingest-пароля.

- **Интеграционные тесты очереди** запускают полный цикл: постановка `Job`, работа воркера, соблюдение дедлайнов `expires_at`, очистка и ручная отмена. Они удостоверяются, что очередь, воркеры и API правильно обмениваются данными и что временные поля (`result_expires_at`, `result_inline_base64`) ведут себя как задумано, включая таймаут 504 и игнор поздних ответов провайдера.

- **Моки провайдеров Gemini/Turbotext** эмулируют три режима — успех, таймаут и ошибка, чтобы интеграционные и контрактные тесты могли проверить реакции системы без реальных внешних вызовов и затрат квот.

- **Unit‑тесты TTL и очистки** фокусируются на доменных функциях: расчёт `T_sync_response`, `T_public_link_ttl`, `T_result_retention`, автозавершение медиаресурсов и выдача `410 Gone`. Они гарантируют корректную работу бизнес-правил, прежде чем эти функции попадут в интеграционные сценарии.

### 1.1 Требования к базе данных для тестов

- Контрактные и интеграционные тесты используют боевую PostgreSQL 16 с драйвером
  `psycopg`. DSN читается из `configs/app.prod.json` (ключ `database.queue_dsn`).
- Для нестандартных окружений задайте `TEST_POSTGRES_DSN` или
  `PHOTOCHANGER_DATABASE_URL`. Эти переменные имеют больший приоритет над
  конфигурацией.
- Установите `psycopg[binary]` — без него фикстуры `postgres_dsn` и `database`
  для репозиториев не запустятся.
- Для локального запуска подключитесь к боевой базе данных или используйте
  актуальную реплику. При необходимости настройте доступ и права вручную.
- После подготовки окружения можно запускать `pytest` напрямую или через
  `./scripts/dev.sh` — фикстуры самостоятельно позаботятся об очистке данных.

### 2. Что можно делегировать LLM, а что придётся сделать вручную

| Подзадача Фазы 3 | Что может сделать LLM | Что нужно выполнить лично |
| --- | --- | --- |
| **3.1 Контрактные тесты API** (позитивные/негативные) | Сгенерировать структуры тестов `pytest`, фикстуры, валидаторы JSON Schema, проверить форматы ответов и статусы. | Запустить тесты локально, настроить окружение (переменные, базу), принять решения по спорным трактовкам контрактов. |
| **3.2 Интеграционные тесты очереди** | Подготовить код тестов, мок-воркеров, сценарии постановки/отмены задач. | Поднять PostgreSQL/очередь, обеспечить тестовые данные и стабильный стенд, интерпретировать нестандартные сбои. |
| **3.3 Моки провайдеров** | Сгенерировать модуль моков, переключатели режимов, типовые ответы Gemini/Turbotext. | Внести реальные ключи/конфигурацию (если нужны), согласовать формат с внешними командами, валидировать соответствие SLA. |
| **3.4 Unit‑тесты TTL** | Написать наборы тест-кейсов для расчётов TTL и очистки, покрыть граничные состояния. | Уточнить фактические значения таймеров, синхронизировать с QA, прогнать тесты на вашей машине. |

В общем, всё, что связано с написанием кода тестов и моков, LLM может подготовить по спецификации. Вам остаются задачи по настройке окружения, запуску и интерпретации результатов, а также любая деятельность, требующая прав доступа или ручной проверки оборудования/базы.

### 3. Что нужно знать, чтобы успешно пройти Фазу 3

- **Картина цели:** На входе уже есть сгенерированные контроллеры/DTO, каркасы сервисов и конфигурация приложения со стабами. Фаза 3 проверяет именно соответствие контрактам, очередь и TTL до включения бизнес-логики.

- **Стратегия тестирования:** Опираться на тест-план — понимать уровни (unit/contract/integration/e2e), целевые сценарии, ответственность команд и требуемые артефакты (отчёты, логи). Это помогает не пропустить негативные кейсы и NFR-проверки.

- **Инфраструктура и инструменты:** Локальная среда — FastAPI + PostgreSQL, файловое хранилище `MEDIA_ROOT`, фикстуры провайдеров; основной раннер `pytest` с маркерами `unit`, `contract`, `integration`. Полезно иметь `schemathesis` или валидацию JSON Schema под рукой.

- **Pre-commit чек-лист:** Перед любыми коммитами/PR — `ruff check`, `ruff format`, `mypy`, `pytest -q -m unit`, `pytest -q -m contract`. Это снижает риски красных пайплайнов и фиксирует регрессии на месте.

- **Политики качества и безопасность:** Минимум 80 % unit-покрытия критичных функций, 100 % контрактов публичного API; контроль SLA (p95 ≤ `T_sync_response`, ≤ 5 % таймаутов). Не логировать бинарные данные, хранить секреты вне репозитория.

- **Коммуникация и артефакты:** После тестов обновлять рабочий журнал и связанные артефакты (PROGRESS, TASKS) согласно базовым инструкциям, чтобы фиксировать результаты и готовность к следующей фазе.

С этими знаниями вы понимаете, какую цель преследует Фаза 3, какие тесты надо построить, что может автоматизировать LLM, и какие организационные шаги необходимы, чтобы зафиксировать успех.
